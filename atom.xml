<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[阿驹]]></title>
  <subtitle><![CDATA[我和你们一样, 我和你们不一样。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ajucs.com/"/>
  <updated>2016-06-24T11:21:36.883Z</updated>
  <id>http://ajucs.com/</id>
  
  <author>
    <name><![CDATA[阿驹]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[UTC+8还是GMT+8?聊聊时间与计时法]]></title>
    <link href="http://ajucs.com/2016/06/24/talk-about-time-and-timer.html"/>
    <id>http://ajucs.com/2016/06/24/talk-about-time-and-timer.html</id>
    <published>2016-06-24T05:17:14.000Z</published>
    <updated>2016-06-24T11:21:36.883Z</updated>
    <content type="html"><![CDATA[<p>今天一位同事问道：“你写入ES的时间字段是考虑过时区处理了的吗？”</p>
<p>原来是我们有一个可能部署在全球各地的软件系统，这个系统会记录各种服务监控指标存入ES（一种数据存档索引系统）。今日那位同事发现他获取的是北京时间，而存入ES系统后却比北京时间晚了8个小时。<br><a id="more"></a></p>
<p>位于美国的系统面向美国用户，时间肯定是以美国当地为准，北京的同理。但如果最终将数据规整到一个系统中时，计时不统一将会导致数据几乎不可用，因为无法界定各个事件发生的先后顺序。</p>
<p>当然要解决这个问题很简单，不论是美国还是中国的系统，存储记录时均以国际标准时为准就可以了。可这件事却引起了我对时间、计时法、计时器的兴趣，于是有了本文。</p>
<h2 id="到底该用UTC+8还是用GMT+8？"><strong>到底该用UTC+8还是用GMT+8？</strong></h2><p>简短的回答是：<strong>对一般人来说没什么区别</strong>。虽然这两种时间有差异，但差异很小。</p>
<p>如果你不是一般人，想寻根究底，请往下看。那么它们到之间以及与其他你可能听过的计时有什么区别呢？为什么要闰秒呢？为什么一天要划分为24小时而非25小时？为什么一小时划分为60分而不是100分？</p>
<p>下面我们进行深入探讨，计时方式依据时间而来，那么首要弄明白的问题就是什么是时间，为什么要计时。</p>
<h2 id="什么是时间">什么是时间</h2><p>长久以来，时间一直是宗教、哲学及科学领域的研究主题之一。但各领域学者还没有找到一个适用于所有领域、具有一致性、没有争议的定义。争议比较小的定义有：“<strong>时间是时钟量测的物理量</strong>。”以及“<strong>时间使得所有事情不会同时发生</strong>。”（What the fuck?! 你没看错，没有同时发生的事。因为这样的定义下，时间是连续不可分割的，其精度无限高，故而事情发生的时间总会在某个精度下没有重合。还有人认为时间是不连续的，后文再谈时间的量子化。）</p>
<p>对于<strong>时间的存在性</strong>也有两种派别，一种以牛顿为代表的认为<strong>时间是宇宙的基本结构，是一个会依序列方式出现的维度</strong>。另一派以莱布尼茨和康德为代表的认为<strong>时间不是任何一种已存在的维度，只是一种心智的概念，是人类为了便于思考宇宙，对事件先后排序比较的人为规定</strong>。</p>
<h2 id="计时">计时</h2><p>日出而作日入而息，这是更古以来人类以及各类动物作息的基本标准。这是进化历程中对时间自然而然地感知。人们观察到天亮是因为太阳会从空中划过，天黑是因为太阳落山了，“一天”的概念就形成了。</p>
<p>如何精确地测定<strong><code>一天</code></strong>的长度就成了最主要问题，进而要确定四季变化，再到制定历法。因为最直观的就是太阳、月亮以及一些恒星在天空中周期性地变化，<code>日、月、年</code>长度的基本参照物就有了。所以制定历法，在全世界都是最早推动天文学发展的主要因素。</p>
<p>以此，用太阳照射物体的影子来测量时间自然被人类想到了，所以发明了<strong>日晷</strong>、<strong>圭表</strong>等，不仅能测天，还能测季节。后来为了满足阴天、夜晚、室内的计时需求，水钟、沙漏等被发明出来。</p>
<h2 id="GMT">GMT</h2><p><strong>GMT</strong>（Greenwich Mean Time）译作<strong>格林威治标准时间</strong>或<strong>格林威治平均时间</strong>。是由英国伦敦皇家格林威治天文台发布的标准时间。民用GMT自1847年起就在大不列颠岛使用。1884年，在华盛顿召开了国际子午线会议，格林威治当地平太阳时被指定为通用日，以午夜零时作为当天的起点。从1924年2月5日开始每隔一小时向全世界报时。被世界广泛采用。</p>
<p><img src="http://7xn3rj.com1.z0.glb.clouddn.com/static/images/jingxian.jpg" alt="jingxian"></p>
<p>GMT时间是如何测量的呢？是观察<strong>真太阳前后两次经过格林威治当地正上空为周期</strong>，即一天。这也是为什么经过格林威治的经线，规定为<strong>0度经线</strong>、<strong>本初子午线</strong>的原因。但因为地球绕太阳公转轨道不是正圆且公转速度不匀速等影响，如此测出来的每天的长短不一，格林威治天文台<strong>连续观测365个长短不一的天，然后求平均值得到一天的长度，称为平太阳日，每一天以格林威治子夜算起。然后再把天划分为时分秒。这种方法和天文学上假想一个太阳（假太阳，亦称平太阳）在天球赤道上匀速运行的观测结果是一致的。</strong></p>
<p><img src="http://7xn3rj.com1.z0.glb.clouddn.com/static/images/chidao.png" alt="chidao"></p>
<p>这种方法测出来的基本单位是天。至于为什么一天要划分为24小时，每小时划分为60分钟，每分钟为60秒，后文再谈。<strong>平太阳日规定了每天正好86400秒</strong>。只测真太阳的话，每天长度不固定，这会给很多需要精确计时的领域带来困扰，是引入平太阳时的原因。</p>
<h2 id="时区">时区</h2><p>国际统一的计时标准有了，但为了解决“18:00点整A地区太阳快落山”而“18:00点整B地区太阳还没出来”的反人类直觉的尴尬现象，<strong>为了让大家都能统一地有“凌晨5点太阳就要出来了”的认知，引入了时区的概念。</strong></p>
<p>理论时区以被15整除的子午线（经线）为中心，向东西两侧延伸7.5度，即每15°划分一个时区，<strong>全球被划分为24个时区</strong>，这是理论时区。但因为国界线并不规则的原因，所以实际划分的时区并不规则。<strong>格林威治所在时区为0时区</strong>。</p>
<p>0度经线（经过格林威治）和180度经线所形成的圆环将地球划分为东西半球。从英国格林威治开始经过亚欧大陆至澳洲再至大约太平洋中间的位置为<strong>东半球</strong>，<strong>在这个方向上，每经过一个时区时间则在0时区的基础上则加 1 作为当地时间</strong>。从格林威治经过大西洋，至南美洲再至北美洲这边为<strong>西半球</strong>，<strong>这个方向上每经过一个时区，当地时间就是在0时区基础上减 1 </strong>。</p>
<p><strong>北京位于东八区，所以北京时间是GMT+8的来由于此。而我们还听说的UTC时间、UT时间、TAI时间、GPS时间等等，都是因为计时方法、计时工具、计时精度的不同而衍生出来的。它们能够代替GMT时间，但因为GMT历史影响深远，保留了这个称呼。而且以格林威治所在时区为0时区也保留了下来。</strong></p>
<h2 id="UT">UT</h2><p>1928年，国际天文联合会引入了<strong>世界时(UT，Universal Time)</strong>的概念来指代GMT。随着科学技术的发达，观测方式越来越多，并不一定非要根据太阳来观察，也可以是一些宇宙射线。发现GMT测算是有偏差的。所以，1955年国际天文联合会又定义了<strong>UT0</strong>、<strong>UT1</strong>和<strong>UT2</strong>三个系统。</p>
<p>UT0系统是由天文观测的世界时，未经任何修正，即与GMT一致。后来天文学家发现在不同地点使用相同的方法观测结果仍不一致，这是由于地轴摆动引起的，UT1就修正了这种影响。后来又发现UT1具有周期性的变化，这种变化和地球自转速率的季节性变动有关，又在UT1的基础上修正了这种地轴摆动影响称为UT2。总结：<strong>GMT = UT0 精度小于 UT1 精度小于 UT2</strong>。（<a href="http://www.hko.gov.hk/gts/time/basicterms-UTandGMTc.htm" target="_blank" rel="external">参考资料</a>）</p>
<p>如今我们称呼的GMT时，实际上是UT时。</p>
<h2 id="TAI">TAI</h2><p><strong>国际原子时</strong>（<strong>International Atomic Time，TAI</strong>）1967年的第13届国际度量衡会议上通过了一项决议，采纳以下定义代替秒的天文定义： <strong>一秒为铯-133原子基态两个超精细能级间跃迁辐射9,192,631,770周所持续的时间</strong>。<strong>TAI</strong>被设定在1958年1月1日0:00:00与<strong>UT2</strong>相同。</p>
<p><strong>现在TAI被国际度量衡局（BIPM）和国际地球自转和参考座标系统服务（IERS）管理，他们依据全球约60个实验室中约240台原子钟提供国际标准时间。</strong></p>
<p>1955年，铯原子钟被发明出来，这种方式比天文观测更稳定，也证实了地球自转的不稳定性。铯原子钟使用铯的同位素铯-133来计时，因为铯-133是所有铯的同位素中最稳定的。至于为什么用铯，而不是其他元素，因为目前尝试过的元素中，铯-133的计时精度最高。在铯原子钟之前，还采用过最常见的氢元素。</p>
<p>1956年美国国家标准局和美国海军天文台开始研究基于原子频率的时间尺度。经过三年的观测与比较，发现不受外场干扰的铯-133原子基态的两个超精细结构能阶跃迁对应辐射的9,192,631,770个周期的持续时间和<strong>历书秒</strong>一致。</p>
<p>关于<strong>秒</strong>单位，英国科学促进协会在1862年表示“所有科学界的人都同意用平均太阳日计算的秒为时间单位。”，并于1874年正式提出厘米-克-秒制，分别为长度、重量、时间的基本单位。定义了<strong>秒为平均太阳日的1/86,400</strong>。</p>
<p>1956年秒被定义为<strong>以1900年历元（即历书时1900年1月1日正午12时）算起的回归年的31,556,925.9747分之一为一秒</strong>。此定义于1960年国际度量衡会议通过，即为<strong>历书秒</strong>。历元是指天文学变量作为参考的一些时刻点。</p>
<h2 id="UTC">UTC</h2><p><strong>协调世界时（Coordinated Universal Time）是目前最主要的世界标准时间</strong>，以<strong>TAI</strong>时为基础，又尽量靠近<strong>UT1</strong>时。但在早期UTC旨在靠近更高精度的世界时UT2的。UT时依据地球自转而测得，但是地球自转在不断变慢，而且平时还会受潮汐力影响，这样秒就会变长，而UTC的参考基准是TAI，很稳定的。故而需要在某些时候给UTC加1秒或减1秒来保证UTC时与UT1时的差值在0.9秒以内，这就是<strong>闰秒</strong>。</p>
<p>PS: 如果你此时质疑了为何Coordinated Universal Time要缩写为UTC，证明你是个细心的人。</p>
<p>1960年，美国海军天文台、英国格林尼治皇家天文台以及英国国家物理实验室协调了它们的无线电广播，由此时间的步长和频率的变化得到了协调，这样产生的时间尺度也被正式命名为“<strong>协调世界时</strong>”。1961年，国际时间局开始在国际上协调不同的UTC时间。</p>
<p>有趣的是直到1967年国际天文学联合会才采用“协调世界时”这个命名，因为英语国家想坚持命名为CUT（Coordinated Universal Time）而法语国家想命名为TUC（Temps Universel Coordonné）。几番争执后相互妥协成了UTC。真是有趣，不仅时间是不同计时系统相互协调的结果，连命名也是协调的结果。</p>
<h2 id="GPST">GPST</h2><p><strong>全球定位系统时（GPS Time）</strong>，GPS由24颗卫星组成，可以向全球范围内提供定位、测速、高精度授时等功能。GPST是由星载原子钟和地面监控中心组成的一种原子时系统。起点是1980年1月6日0时，此时刻与UTC对齐。</p>
<p>虽然以TAI时为基础的UTC时与GPST时都是使用原子钟，但是还是有微小差异的。差异一来自组成各自计时系统原子钟的数量，TAI为全球范围的240多个，而GPST为20多个。差异二是GPST所用的原子钟在高速飞行的卫星上时间长度会发生变化，所以还需要使用《相对论》进行卫星时间修正。差异三在UTC为了和UT1保持较小的误差，还得跳秒。</p>
<p>下面是几种时间的直观对比（<a href="http://www.leapsecond.com/java/gpsclock.htm" target="_blank" rel="external">参考资料</a>）：<br><img src="http://7xn3rj.com1.z0.glb.clouddn.com/static/images/time.png" alt="time"></p>
<p>通过上图发现几种时间的差异之处。UTC与GMT看起来已经相差两秒，可能是网络原因导致的，实际上它们应该相差在1秒之内。大多数时候打开看应该是GMT慢了1秒。</p>
<p>国内的北斗导航系统也能提供授时服务，同样是卫星上载有原子钟。早期的北斗卫星采用瑞士进口原子钟，目前已经开始使用国产原子钟。截止2016年6月12日，已经发射23颗北斗卫星，其中21颗在进行服务。</p>
<h2 id="24小时、60分钟的由来">24小时、60分钟的由来</h2><p>为什么一年分为4季而非5季？分为12个月而非13个月？为什么平年是365天？为什么每隔4年是一个闰年？为什么闰年是366天？为什么每天分为24小时而非20小时？为什么每小时分为60分钟而不是100分钟？为什么每分钟分为60秒而不是70秒？</p>
<p>如果你跟我一样都疑惑过以上问题并且想知道答案的话，那继续往下看吧。本节估计是本文最有趣的一节了。</p>
<p>首先解决简单的问题。一年有365天是因为天文观测到比较精确地是每经过365.25个昼夜就是地球围绕太阳公转一年。而要隔4年就闰年的原因也来自于此。每4年的前3年并不会将那0.25天算上，不方便，所以第4年的时候就凑个整为366天。</p>
<p>为什么一年要分为四个季节呢？可能是对大自然比较粗略的感知，极冷和极热分别为冬夏两个季节，而这两个季节之间又有两个不冷不热的季节连接，故而有了春夏秋冬四个季节。也许还有其他地理方面的观察直接推动了将季节划分为4个。一年分为12个月也比较容易知道是为什么，观察一年里月球的运动即可得到12这个数值。</p>
<p>然而为何要将一天划分为24个小时？</p>
<p>埃及有出土约公元前1500多年的日晷，呈T型，置于地上将日出至日落划分为12份。为什么划分采用12这个数值的原因有几个。一是月球绕地球的转动周期。二是人类除了大拇指之外的关节数，方便数数。三是埃及人还观察到天上特定的36颗恒星可以将天空分为相等的部分，依此作为测量系统。天黑时可以依次看见18颗星星，但是黄昏和黎明时各占3颗星星不容易看见，天空纯黑的时候可以看到12颗。黑夜被划分为12份就有了，白天再同理划分为12份。也就有了24小时的雏形。</p>
<p>那么为什么每个小时被划分为60分钟呢？在很长的时期，是没有分钟这种划分的，因为没有普世而精确的工具。按60来划分大概是从希腊托勒密那代（公元前100年左右）开始，从古巴比伦传进来的。据说古巴比伦人是跟苏美人（约公元前3000~2000年）学的。</p>
<p>无独有偶，中国的天干地支计时法，大概出现于公元前一千多年，每天也被分为12个时辰，每个时辰被划分为两小部分。而天干地支的特定组合是60，比如用于天干地支纪年法，60年一甲子，一个轮回。</p>
<p>不论是从苏美人那里学的，还是相隔千万里的中华文明，为何都用12、60这些数值？有种说法是源于我们的手掌，一只手用大拇指数关节，就是12，另一只手用手指做进位，5个12就是60。</p>
<p>而且我们现在发现，用60真的太方便了。60的约数有1,2,3,4,5,6,10,12,15,20,30，我们可以很轻易地把60分钟划分为各种相等的组合。可以划分为2个30分钟，也可以划分为4个15分钟等等。</p>
<p>在写此文中，还阅读了一些我们老祖先发明的太极八卦相关的资料。无极生太极，太极生两仪，两仪生四象，四象生八卦。八卦又可以演绎为六十四卦。这实际就是一个二进制系统。然而天干地支这些和它结合在一起，2进制（及其衍生的八进制、十六进制）、10进制、60进制都有体现。很是了不得，以后再探究这点。</p>
<p>数，是人类认识宇宙的最基本最重要工具。谁对数的研究和认识走在人类前沿，那么那个文明也将走在世界最前沿。</p>
<p>你，心里有没有数？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天一位同事问道：“你写入ES的时间字段是考虑过时区处理了的吗？”</p>
<p>原来是我们有一个可能部署在全球各地的软件系统，这个系统会记录各种服务监控指标存入ES（一种数据存档索引系统）。今日那位同事发现他获取的是北京时间，而存入ES系统后却比北京时间晚了8个小时。<br>]]>
    
    </summary>
    
      <category term="-杂谈" scheme="http://ajucs.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在Python里应用SOLID原则]]></title>
    <link href="http://ajucs.com/2016/06/17/use-S-O-L-I-D-in-python.html"/>
    <id>http://ajucs.com/2016/06/17/use-S-O-L-I-D-in-python.html</id>
    <published>2016-06-17T04:10:31.000Z</published>
    <updated>2016-06-17T10:12:52.627Z</updated>
    <content type="html"><![CDATA[<p>如今OOP编程大行其道。不少人以为用编程语言里的class关键字定义一个类，然后用类创建一个对象就是OOP了。肤浅！</p>
<p>OOP编程很贴近人们的正常思维方式，所以容易被接受，而且应用也很广泛。的确，这给编程带来了很大的好处。但并不是任何人都能深谙OOP的本质。简略证明如下：如果把“女朋友”作为一个类，你自己的女朋友就是你的对象，是“女朋友”类的具体的实例。如果你能熟练掌握“女朋友”这个类的特性以及方法，还不能创建一个实例么？你没女朋友，说明你没吃透女朋友类，进而说明你肯定没理解好OOP。但创建了一个实例出来也并不能证明你就吃透了这个类。<br><a id="more"></a></p>
<p>以上是闲话。</p>
<p>是否感觉你在OOP时总是要么很随意的定义class然后创建object，要么在生搬硬套所谓的设计模式？</p>
<p>是否感觉你的程序真的很脆弱（比如一天的告警邮件就是几千封）？</p>
<p>是否觉得灵活性差可扩展性不足（比如要增加新功能，不能通过某种优雅的方式插入现在的系统，而是copy一份类似的代码改一改）？</p>
<p>是否觉得子模块/子系统之间依赖关系混乱，粘黏性强（你渴望用TDD或unittest来保证系统每次迭代的质量，但你发现基于你的代码难以写testcase，为啥？因为依赖混乱、粘黏性强 独立的程序单元基本没有，没有unit请问怎么unittest？）？</p>
<p>如果我们的代码存在以上任何一种问题，包括没提到的一些导致系统烂的问题，如果你还在用OOP的话，那么好好根据本文思考一下你的代码该如何改进。</p>
<h2 id="SOLID是什么？">SOLID是什么？</h2><p><strong>SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）</strong>是由罗伯特·C·马丁（其著作有《敏捷软件开发——原则、模式与实践》、《Clean Code》）在21世纪早期引入的记忆术首字母缩略字，<strong>指代了面向对象编程和面向对象设计的五个基本原则。</strong></p>
<p>SOLID被典型的应用于测试驱动开发（TDD，TDD也并不那么美好，以后再说），并且是敏捷开发以及自适应软件开发的基本原则的重要组成部分。</p>
<p>如果你们在践行敏捷开发和尝试TDD，那么有什么理由不掌握这五个几本原则呢？这五个原则并完全是罗伯特·C·马丁原创的，别弄混了。</p>
<p><strong>但是，原则并不是规则，更不是教条，原则对智者来说是指导，对愚者来说是遵从。</strong> SOLID以及本文只起到抛砖引玉的作用。</p>
<table>
<thead>
<tr>
<th style="text-align:center">首字母</th>
<th>指代</th>
<th>概念</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td>单一功能原则</td>
<td>对象应该仅具有一种单一功能</td>
</tr>
<tr>
<td style="text-align:center">O</td>
<td>开闭原则</td>
<td>软件体应该是对于扩展开放的，但是对于修改封闭的</td>
</tr>
<tr>
<td style="text-align:center">L</td>
<td>里氏替换原则</td>
<td>程序中的对象应该是可以在不改变程序正确性的前提下被它的子类对象所替换的</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td>接口隔离原则</td>
<td>多个特定客户端接口要好于一个宽泛用途的接口</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td>依赖反转原则</td>
<td>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口；抽象接口不应该依赖于具体实现，而具体实现则应该依赖于抽象接口。</td>
</tr>
</tbody>
</table>
<h2 id="为什么要用SOLID原则指导OOP？">为什么要用SOLID原则指导OOP？</h2><p><strong>容易编写易于维护的、复用率高的、易于测试的OO代码。</strong> 为了达到这个目的，你可以自己写上数十万行代码并研究总结出类似的规律，也可以先在这个原则的指导下试试看。</p>
<h2 id="Talk_is_cheap-_Show_me_the_code-">Talk is cheap. Show me the code.</h2><p>现在我们要用OOP来实现一段最基本的 “洗车服务” 代码。需求如下：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">洗车服务</span><br><span class="line">  -<span class="ruby"> 洗车作业任务</span><br><span class="line"></span>      汽车进入洗车机时</span><br><span class="line">        注册洗车任务</span><br><span class="line">  -<span class="ruby"> 顾客通知</span><br><span class="line"></span>      洗车完毕</span><br><span class="line">        向顾客发出消息通知</span><br><span class="line">  -<span class="ruby"> 报表</span><br><span class="line"></span>      客户端发出报表请求时</span><br><span class="line">        向该顾客展示他的所有洗车信息</span><br></pre></td></tr></table></figure></p>
<p>也许你的代码其中一段如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWashService</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sms_sender)</span>:</span></span><br><span class="line">        self.persistence = &#123;&#125;</span><br><span class="line">        self.sms_sender = sms_sender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">require_car_wash</span><span class="params">(self, car, customer)</span>:</span></span><br><span class="line">        service_id = uuid.uuid4().hex</span><br><span class="line">        self.persistence[service_id] = (car, customer)</span><br><span class="line">        <span class="keyword">return</span> service_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wash_completed</span><span class="params">(self, service_id)</span>:</span></span><br><span class="line">        car, costomer = self.persistence[service_id]</span><br><span class="line">        self.sms_sender.send(mobile_phone=customer.mobile_phone,</span><br><span class="line">            text=<span class="string">'Car %&#123;car.plate&#125; washed'</span>.format(car=car))</span><br></pre></td></tr></table></figure></p>
<h2 id="单一职责原则">单一职责原则</h2><p>为什么要遵循这个原则？交警在路边可以去劝阻路边打架斗殴的，在民警未到时也应该去劝阻，但交警就该去劝架了吗？道路交通怎么办？让民警又干什么？在纠纷频发的地方如果只有交警而无民警，那是治安体制有问题没在那里安插民警，而不是交警袖手旁观。</p>
<p>所以，<strong>分清楚你“必须做”和“可以做”的事情</strong>。每个角色做好必须做的事情就很好了。如果还有一些事情没人做，那就创造角色让他去做。</p>
<p>那么以单一职责原则来看上面的代码有什么问题？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWashService</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sms_sender)</span>:</span></span><br><span class="line">        self.persistence = &#123;&#125;    <span class="comment"># A</span></span><br><span class="line">        self.sms_sender = sms_sender  <span class="comment"># B</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">require_car_wash</span><span class="params">(self, car, customer)</span>:</span></span><br><span class="line">        service_id = uuid.uuid4().hex</span><br><span class="line">        self.persistence[service_id] = (car, customer)    <span class="comment"># A</span></span><br><span class="line">        <span class="keyword">return</span> service_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wash_completed</span><span class="params">(self, service_id)</span>:</span></span><br><span class="line">        car, costomer = self.persistence[service_id]      <span class="comment"># A</span></span><br><span class="line">        self.sms_sender.send(mobile_phone=customer.mobile_phone,</span><br><span class="line">            text=<span class="string">'Car %&#123;car.plate&#125; washed'</span>.format(car=car))    <span class="comment"># B</span></span><br></pre></td></tr></table></figure></p>
<p>经过一点改造后，写出了下面的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWashService</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, notifier, repository)</span>:</span></span><br><span class="line">        self.notifier = notifier</span><br><span class="line">        self.repository = repository</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enter_in_car_wash</span><span class="params">(self, car, customer)</span>:</span></span><br><span class="line">        job = CarWashJob(car, costomer)</span><br><span class="line">        self.repository.put(job)</span><br><span class="line">        <span class="keyword">return</span> job</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wash_completed</span><span class="params">(self, service_id)</span>:</span></span><br><span class="line">        car_wash_job = self.repository.find_by_id(service_id)</span><br><span class="line">        self.notifier.job_completed(car_wash_job)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">service_by_customer</span><span class="params">(self, customer)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.repository.find_by_customer(customer)</span><br></pre></td></tr></table></figure></p>
<h2 id="依赖反转原则">依赖反转原则</h2><p>为何要遵循这个原则？你会把台灯电线直接焊接在墙上的电线上吗？</p>
<p><strong>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</strong>台灯是高层次模块，电路是低层次模块，台灯依赖于台灯的插头而非电线以获取电源；电路依赖于插座为外部提供电源而非直接将电线暴露出去。</p>
<p><strong>抽象接口不应该依赖于具体实现，而具体实现应该依赖于抽象接口</strong>。三针插头可以被台灯用，也可以被冰箱用，所以抽象接口（插头）并不依赖于背后的具体实现（台灯/冰箱）。而冰箱因为功率较大，一定要有能接地线的三针插头，所以具体实现依赖于抽象接口。</p>
<p>在Python中，编译或程序启动时的依赖是import语句的内容，而运行时的依赖就是被调用的函数、方法等。</p>
<p>也许你写出了类似下面的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWashService</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, repository)</span>:</span></span><br><span class="line">        self.repository = repository</span><br><span class="line">        <span class="comment"># self.notifier = SmsNotifier()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enter_in_car_wash</span><span class="params">(self, car, customer)</span>:</span></span><br><span class="line">        job = CarWashJob(car, customer)</span><br><span class="line">        self.repository.put(job)</span><br><span class="line">        <span class="keyword">return</span> job</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wash_completed</span><span class="params">(self, service_id)</span>:</span></span><br><span class="line">        car_wash_job = self.repository.find_by_id(service_id)</span><br><span class="line">        SmsNotifier.send_sms(car_wash_job)    <span class="comment">#有问题</span></span><br><span class="line">        <span class="comment"># self.notifier.send_sms(car_wash_job)</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码的问题主要出在直接调用<code>SmsNotifier</code>类方法那行。如果你是按被注释的那两行写的，还是存在如下同样的问题。</p>
<p><strong>问题一是全局状态问题</strong>，直接使用了全局变量<code>SmsNotifier</code>，我们说过写代码能使用局部变量的就别使用全局变量，一是全局变量不使用时并不会被释放内存，二是全局变量对其他对象来说都是可见的，也是可修改的，会给程序带来更多的不确定性。</p>
<p><strong>问题二在于隐式依赖问题</strong>。并不能从<code>CarWashService</code>的构造方法或初始化方法中知道它依赖了<code>SmsNotifier</code>类，这对代码的可读性和易于理解性都会带来障碍。比如在别的模块中使用了<code>CarWashService</code>类的时候，不层层追查的话，神仙才知道它还依赖了<code>SmsNotifier</code>。</p>
<p><strong>问题三是依赖于具体的实现</strong>。<code>CarWashService</code>对象直接依赖了具体的<code>send_sms</code>方法。这样做能够实现通知的需求，但是<strong>扩展性差</strong>。如果又要同时用电话、邮件、微信等通知方式，又该要来改这里的老代码了。从现实世界中的例子来看，在较大的机构中都会有类似“传达室”的小机构。要怎么改进就显而易见了。</p>
<p>改进后的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWashService</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, notifier, repository)</span>:</span></span><br><span class="line">        self.repository = repository</span><br><span class="line">        self.notifier = notifier</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enter_in_car_wash</span><span class="params">(self, car, customer)</span>:</span></span><br><span class="line">        job = CarWashJob(car, customer)</span><br><span class="line">        self.repository.put(job)</span><br><span class="line">        <span class="keyword">return</span> job</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wash_completed</span><span class="params">(self, service_id)</span>:</span></span><br><span class="line">        car_wash_job = self.repository.find_by_id(service_id)</span><br><span class="line">        self.notifier.job_completed(car_wash_job)</span><br></pre></td></tr></table></figure></p>
<p>上面通过<strong>依赖注入</strong>的方式将<code>notifier</code>对象作为初始化参数传递给<code>CarWashService</code>类。这种写法化解了上面提到的三种负面影响。</p>
<p><strong>依赖注入是实现依赖反转的一种方式，两者并不等同。</strong>两个存在依赖关系的对象A、B，A使用B的服务，B可以向A提供服务，我们并不让A直接使用B，而是将B传递给A，使B成为A的一部分。这就是依赖注入。</p>
<p>其实<strong>依赖反转</strong>也相当于应用了<strong>适配器模式</strong>，举例中的插座和插头是抽象接口，也就是台灯电线和供电电线的适配器，传达室也是消息发送人和消息接收人的适配器。示例代码中被抽象出来的notifier就是适配器对象。洗车服务只知道洗完车要通知，但是具体用哪些途径通知，当前结束的任务该通知给谁，在什么时间通知，都由<code>notifier</code>去完成。程序的耦合性会进一步降低，灵活性进一步增强。</p>
<h2 id="开闭原则">开闭原则</h2><p>为何要遵循开闭原则？当你想增加自己的御寒能力只用在身体外加衣服而非做个开胸手术。软件体也一样，观察人体这个造物者的完美之作，把它的规律用在软件体上，就可以造出更完美的软件。<strong>好的设计可以让你在为系统新增功能时添加新代码即可而无需修改老代码。</strong></p>
<p>洗车服务的数据需要得到保存，可能保存在内存、文件、数据库等等。但这些功能都是几乎一致的，所以你很可能写出了如下抽象类，希望其他子类都来继承它。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceJobReository</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, job)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_by_id</span><span class="params">(self, job_id)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_by_customer</span><span class="params">(self, customer)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InMemoryJobReository</span><span class="params">(InterfaceJobReository)</span>:</span></span><br><span class="line">	<span class="string">"""注意这里的继承"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._storage = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, job)</span>:</span></span><br><span class="line">        self._storage[job.service_id] = job</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_by_id</span><span class="params">(self, job_id)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._storage.get(job_id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_by_customer</span><span class="params">(self, customer)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [job <span class="keyword">for</span> job <span class="keyword">in</span> self._storage.values()</span><br><span class="line">                <span class="keyword">if</span> job.has_customer(customer)]</span><br></pre></td></tr></table></figure></p>
<p>以上写法这是符合开闭原则的，因为对于扩展成用文件保存时，只需要另外增加一个<code>InFileJobReository</code>类并写出相关实现就好了，并不会动任何一行已有代码。</p>
<p><strong>秉承鸭子类型的理念，我们还可以简化代码，可以无需写那个抽象类</strong>。只需要让子类都继承Python的<code>object</code>类，例如<code>InMemoryJobReository(object)</code>， 剩下的一个字符都不用变，也能达到同样效果，但这似乎也留下了更多犯错误的可能，其中平衡点自行拿捏。</p>
<h2 id="里氏替换原则">里氏替换原则</h2><p>为何要遵循这个原则？古猿作为基类，直立人是古猿的后代，现代人是直立人的后代，现代人可以代替直立人这是很自然的事情。这是自然法则和规律，为什么不可以应用到软件中来？如果你有一天看到个看起来像现代人，叫起来也像现代人，而她却需要充电，那她肯定是基于错误的基类生成出来的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InMemoryJobReository</span><span class="params">(dict)</span>:</span></span><br><span class="line">	<span class="string">"""注意这里的继承"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, job)</span>:</span></span><br><span class="line">        self[job.service_id] = job</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_by_id</span><span class="params">(self, job_id)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.get(job_id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_by_customer</span><span class="params">(self, customer)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [job <span class="keyword">for</span> job <span class="keyword">in</span> self.values()</span><br><span class="line">                <span class="keyword">if</span> job.has_customer(customer)]</span><br></pre></td></tr></table></figure></p>
<p>原先是直接使用<code>dict</code>类的对象赋给<code>self._storage</code>，来完成工作。现在继承了<code>dict</code>类，相当于原来直接使用父类<code>dict</code>，而现在使用的是<code>dict</code>的子类。现在<code>InMemoryJobReository</code>的对象完全可以代替父类了。</p>
<p>Python在接口实现时并不强制性继承。就算A和B是完全不相关的类，你还可以通过<code>abc</code>模块来将A类注册给B类，让A成为B的虚拟子类。如此强大灵活，比起东拼西凑，多多考虑如何提高到代码的重用率。</p>
<h2 id="接口隔离原则">接口隔离原则</h2><p>为何要这么做？人嘴巴和鼻孔的功能应该不一样吧？否则的话，全人体只需要一个孔就行了（嘿~ 嘿~ 嘿~）。</p>
<p>本节就没有代码了，因为示例只直接地讲了一个接口，不过我们在这过程中拆分了一些接口，不是吗？</p>
<p>很多时候，根据这五条原则多多设计后再写代码，就能写出很好的代码了。这些基本原则在很多情况下也是相互促进，相互兼容，相互满足的。这过程中针对实际情况的不同你自己做的变通，也就相当于是运用了各类设计模式。比如在依赖反转一节中提到的适配器模式，控制反转模式等等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如今OOP编程大行其道。不少人以为用编程语言里的class关键字定义一个类，然后用类创建一个对象就是OOP了。肤浅！</p>
<p>OOP编程很贴近人们的正常思维方式，所以容易被接受，而且应用也很广泛。的确，这给编程带来了很大的好处。但并不是任何人都能深谙OOP的本质。简略证明如下：如果把“女朋友”作为一个类，你自己的女朋友就是你的对象，是“女朋友”类的具体的实例。如果你能熟练掌握“女朋友”这个类的特性以及方法，还不能创建一个实例么？你没女朋友，说明你没吃透女朋友类，进而说明你肯定没理解好OOP。但创建了一个实例出来也并不能证明你就吃透了这个类。<br>]]>
    
    </summary>
    
      <category term="OOP" scheme="http://ajucs.com/tags/OOP/"/>
    
      <category term="Python" scheme="http://ajucs.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mesosphere DCOS 常见问题]]></title>
    <link href="http://ajucs.com/2016/04/27/Mesosphere-DCOS-Questions.html"/>
    <id>http://ajucs.com/2016/04/27/Mesosphere-DCOS-Questions.html</id>
    <published>2016-04-27T21:20:01.000Z</published>
    <updated>2016-04-28T03:25:24.242Z</updated>
    <content type="html"><![CDATA[<p>本文摘自Mesosphere 官网，可以从这些常见问题中明确Mesosphere DOCS的定位以及作用。并可一瞥其架构。<br><a id="more"></a></p>
<h2 id="Mesosphere_DCOS_和_Apache_Mesos有何区别？">Mesosphere DCOS 和 Apache Mesos有何区别？</h2><p>DCOS 是一个建立在开源Mesos之上的强大的有商业支持的软件产品。主要改进包括命令行和Web界面，很容易打包与安装，它还有不断壮大的技术合作伙伴生态系统。</p>
<h2 id="DCOS集群和私有云或虚拟化有何区别？">DCOS集群和私有云或虚拟化有何区别？</h2><p>DCOS是下一代的私有云。它和虚拟机之类的软件不同，因为DCOS可以组织任何形式的服务器——物理机，虚拟机，云——作为单一的共享资源池。它的Mesos内核会动态分配必要的计算、存储、网络资源，而不是预先配置的机器镜像。</p>
<h2 id="DCOS与Kuneretes、Docker这类容器技术有何区别？">DCOS与Kuneretes、Docker这类容器技术有何区别？</h2><p>DCOS对Kubernetes和Docker都支持。因为DCOS在服务器级别管理基础设施，它是运行在Linux服务器之上的，它可以大规模地启动Docker容器。Mesosphere和Google合作把Kuneretes引入DCOS。Kuneretes直接和DCOS API交互，就像任何其他的DCOS服务一样。</p>
<h2 id="我可以在DCOS里运行什么类型的工作负载？">我可以在DCOS里运行什么类型的工作负载？</h2><p>DCOS里可以运行几乎任何类型的工作负载。它支持诸如Cassandra和MemSQL这类的数据库服务，Hadoop 和 Spark这类大数据系统，也支持Marathon 和 Kubernetes这种编排服务用于托管长期运行的云应用。</p>
<h2 id="我可以编写自己的运行在DCOS上的分布式服务吗？">我可以编写自己的运行在DCOS上的分布式服务吗？</h2><p>可以。Mesosphere DCOS目前支持所有Mesos框架，并且很快将会推出软件开发工具包（SDK）以便更容易得编写新服务或者集成现有服务，即利用DCOS固有的伸缩性、灵活性和高可用性。</p>
<h2 id="Mesos和DCOS有哪些常见使用案例？">Mesos和DCOS有哪些常见使用案例？</h2><p>尽管DCOS支持几乎所有类型的工作负载，但特别流行用它支持PaSS产品，大数据分析（例如Hadoop, Spark 和 Kafka），还有HDFS、Cassandra 和 MemSQL这类有状态服务。即将支持更多样化的服务，包括MySQL这类传统数据库服务。</p>
<h2 id="我可以下载社区版的DCOS并在本地运行吗？">我可以下载社区版的DCOS并在本地运行吗？</h2><p>DCOS社区版目前还不支持下载，也不支持在本地服务器上运行。用户需要这种功能时应该联系Mesosphere了解DCOS企业版。</p>
<h2 id="我没有数千台服务器时使用DOCS还有意义吗？">我没有数千台服务器时使用DOCS还有意义吗？</h2><p>有。尽管像Twitter这种Mesos大用户受到了很多关注，但很多Mesos和DCOS早期用户在几百个或十几个节点上也能成功运行。DCOS为小型集群提供了便利，并且当你需要的时候还可以扩展至数万台节点。</p>
<h2 id="Mesosphere_DCOS开源吗？">Mesosphere DCOS开源吗？</h2><p>DCOS是不开源的，但它是建立在开源基础之上的，包括Apache Mesos, Marathon 和 Chronos。DCOS可以运行与集成许多流行的开源技术。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文摘自Mesosphere 官网，可以从这些常见问题中明确Mesosphere DOCS的定位以及作用。并可一瞥其架构。<br>]]>
    
    </summary>
    
      <category term="DCOS" scheme="http://ajucs.com/tags/DCOS/"/>
    
      <category term="Mesos" scheme="http://ajucs.com/tags/Mesos/"/>
    
      <category term="cloud" scheme="http://ajucs.com/tags/cloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[管理多个SSH Key以支持多个Git账号]]></title>
    <link href="http://ajucs.com/2016/04/20/use-multi-ssh-key-for-git.html"/>
    <id>http://ajucs.com/2016/04/20/use-multi-ssh-key-for-git.html</id>
    <published>2016-04-20T01:30:02.000Z</published>
    <updated>2016-04-20T07:40:35.912Z</updated>
    <content type="html"><![CDATA[<p>SSH Key 可以方便地解决系统登录的问题，不用每次提交代码时输入相关Git平台的登录密码。</p>
<p>由于各种各样的原因，程序猿一般都有多台电脑或多个开发系统环境，同样也有多个Git账户，最起码的可能有一个GitHub账户加公司内部的一个GitLab账户。可能不同的账户有不同的用户名，邮箱等。</p>
<h2 id="1-_生成SSH密钥">1. 生成SSH密钥</h2><ul>
<li><h4 id="生成默认公钥">生成默认公钥</h4>先确认系统中是否已有默认的SSH密钥（使用的是公钥，之后都称公钥）存在。</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~<span class="regexp">/.ssh/id</span>_rsa.pub</span><br></pre></td></tr></table></figure>
<p>如果已经有了则不用生成默认的公钥了，如果没有，则按照如下命令生成。生成后再用上述<code>cat</code>命令查看公钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"<span class="variable">$your_email</span>"</span></span><br></pre></td></tr></table></figure>
<p>将上述的<code>$your_email</code>替换为你想使用的默认email地址。如我在工作电脑上生成默认公钥时邮箱使用的是公司内部邮箱。在私人电脑上则用的是本人Gmail邮箱。</p>
<a id="more"></a>
<ul>
<li><h4 id="生成更多的公钥">生成更多的公钥</h4>按如下命令生成新的公钥，注意这次要天加输出文件的名字，以免覆盖默认公钥。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">'$another_email'</span> <span class="operator">-f</span> github</span><br></pre></td></tr></table></figure>
<p>如需更多的SSH公钥按上述命令生成即可。<strong>注意输出文件名字不要相同，无需加<code>.pub</code>后缀</strong>。</p>
<h2 id="2-_多个操作系统用SSH_Key访问同一个Git平台">2. 多个操作系统用SSH Key访问同一个Git平台</h2><p>最常见的情况是我们需要在“工作电脑”和“私人电脑”中都能够方便的向同一个GitHub仓库提交代码。</p>
<p>进入<code>.ssh</code>目录，把该目录下的<code>github</code>以及<code>github.pub</code>拷贝至其他系统中的<code>.ssh</code>目录下，然后将公钥的内容复制，添加到GitHub的账户即可。gitlab、coding.net等平台类似。</p>
<p>除了拷贝的方式共用一份公钥，也可以在不同的系统里另外生成公钥，然后再逐个添加至Git平台。</p>
<h2 id="3-_同一个操作系统用不同的SSH公钥访问不同的Git平台">3. 同一个操作系统用不同的SSH公钥访问不同的Git平台</h2><ul>
<li><h4 id="创建ssh配置文件">创建ssh配置文件</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~<span class="regexp">/.ssh/config</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="添加ssh配置">添加ssh配置</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host    github                              <span class="comment"># ssh别名，随意取</span></span><br><span class="line">    HostName        github.com              <span class="comment"># 主机名</span></span><br><span class="line">    Port            <span class="number">22</span>                      <span class="comment"># SSH端口号</span></span><br><span class="line">    PreferredAuthentications publickey      <span class="comment"># 认证类型</span></span><br><span class="line">    <span class="keyword">User</span>            <span class="title">git</span>                     <span class="comment"># 用户</span></span><br><span class="line">    IdentityFile    ~/.ssh/github</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将上述配置内容添加至 <code>~/.ssh/config</code> 文件即可。注意按需修改配置内容，勿一成不变地复制。要添加更多的Git平台账户时继续在config文件中按上述格式追加配置即可。</p>
<h2 id="4-_遇到的问题">4. 遇到的问题</h2><p>当添加配置完成后通过如下命令验证是否可以用公钥访问：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ssh</span> -T git<span class="variable">@github</span>.com   <span class="comment"># 这里的github取自上述 config 文件中的 Host 值</span></span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="配置文件权限错误">配置文件权限错误</h4>提示如下错误：</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bad owner <span class="keyword">or</span> permissions <span class="function_start"><span class="keyword">on</span></span> /home/vagrant/.ssh/config</span><br></pre></td></tr></table></figure>
<p>原因是config文件的所有者或权限有问题。按如下命令修复：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">chmod <span class="number">600</span> *</span><br></pre></td></tr></table></figure>
<p>再执行<code>ssh -T github</code>得到如下结果：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi denglj! You've successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="访问github无权限">访问github无权限</h4>请参考资料：<a href="https://help.github.com/articles/error-permission-denied-publickey/" target="_blank" rel="external">https://help.github.com/articles/error-permission-denied-publickey/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>SSH Key 可以方便地解决系统登录的问题，不用每次提交代码时输入相关Git平台的登录密码。</p>
<p>由于各种各样的原因，程序猿一般都有多台电脑或多个开发系统环境，同样也有多个Git账户，最起码的可能有一个GitHub账户加公司内部的一个GitLab账户。可能不同的账户有不同的用户名，邮箱等。</p>
<h2 id="1-_生成SSH密钥">1. 生成SSH密钥</h2><ul>
<li><h4 id="生成默认公钥">生成默认公钥</h4>先确认系统中是否已有默认的SSH密钥（使用的是公钥，之后都称公钥）存在。</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~<span class="regexp">/.ssh/id</span>_rsa.pub</span><br></pre></td></tr></table></figure>
<p>如果已经有了则不用生成默认的公钥了，如果没有，则按照如下命令生成。生成后再用上述<code>cat</code>命令查看公钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"<span class="variable">$your_email</span>"</span></span><br></pre></td></tr></table></figure>
<p>将上述的<code>$your_email</code>替换为你想使用的默认email地址。如我在工作电脑上生成默认公钥时邮箱使用的是公司内部邮箱。在私人电脑上则用的是本人Gmail邮箱。</p>]]>
    
    </summary>
    
      <category term="git" scheme="http://ajucs.com/tags/git/"/>
    
      <category term="ssh" scheme="http://ajucs.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python性能优化之记忆化（Memoization）]]></title>
    <link href="http://ajucs.com/2016/01/22/python-memoization.html"/>
    <id>http://ajucs.com/2016/01/22/python-memoization.html</id>
    <published>2016-01-22T06:43:16.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<h2 id="记忆化（Memoization）介绍">记忆化（Memoization）介绍</h2><p>简单说来 Memoization 是一种利用缓存来加速函数调用的技术手段，将消耗较大的调用结果存储起来，当再次遇到相同调用时就从缓存读取结果而无需重新计算。<br><strong>有一个限制条件是该函数必须是纯函数式的</strong>，相当于函数式编程中的不可变性，即输入一致时输出一定不会改变。比如计算平方的函数就满足这种条件，<code>square(3)</code> 的结果永远是<code>9</code>，所以我们才能把它的结果存储起来，下次需要知道<code>3</code>的平方的结果时，无需计算，直接从内存中读取就好了。<br><a id="more"></a><br>而那些依赖于可变的参数的函数，则不可使用这种方式进行加速。比如获取系统当前登录用户数量的函数，也许参数都是固定的，但返回值却是可变的，这是由系统中即时登录的用户数量决定的，缓存起来就没意义了。</p>
<p>这里的缓存介质，可以是内存，可以是硬盘上的文件，可以是数据库，总之，能使之加速则认为是有效的。我们经常提及的 <code>memcached</code> 分布式内存对象缓存系统也是一种基于记忆化（memoization）的优化方式。今天不讲 <code>memcached</code> ，而是一种更简便小巧的办法，然而，它们的基本原理是一样的，它们都实现了LRU（Least Recently Used）缓存算法， 只缓存最少的最近使用过的数据。</p>
<h2 id="Python内置函数缓存装饰器">Python内置函数缓存装饰器</h2><p><strong><code>@functools.lru_cache(maxsize=128, typed=False)</code></strong>，<code>maxsize</code> 参数是指最大缓存多少个调用，如果赋值为 <code>None</code> 则是无限制缓存，且关闭 LRU 功能。<code>typed</code> 参数控制函数参数类型不同时是否单独缓存。设置为<code>True</code>时， 例如<code>f(3)</code>和<code>f(3.0)</code>将会区别对待。</p>
<p>下面这个例子是缓存静态web内容的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="decorator">@lru_cache(maxsize=32)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pep</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="string">'Retrieve text of a Python Enhancement Proposal'</span></span><br><span class="line">    resource = <span class="string">'http://www.python.org/dev/peps/pep-%04d/'</span> % num</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> urllib.request.urlopen(resource) <span class="keyword">as</span> s:</span><br><span class="line">            <span class="keyword">return</span> s.read()</span><br><span class="line">    <span class="keyword">except</span> urllib.error.HTTPError:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Not Found'</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">8</span>, <span class="number">290</span>, <span class="number">308</span>, <span class="number">320</span>, <span class="number">8</span>, <span class="number">218</span>, <span class="number">320</span>, <span class="number">279</span>, <span class="number">289</span>, <span class="number">320</span>, <span class="number">9991</span>:</span><br><span class="line"><span class="prompt">... </span>    pep = get_pep(n)</span><br><span class="line"><span class="prompt">... </span>    print(n, len(pep))</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>get_pep.cache_info()</span><br><span class="line">CacheInfo(hits=<span class="number">3</span>, misses=<span class="number">8</span>, maxsize=<span class="number">32</span>, currsize=<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p><code>lru_cache</code>装饰器是Python3.2新增的，Python3.3新增了<code>typed</code>可选参数。</p>
<h2 id="Python2的实现">Python2的实现</h2><p>Python2中没有<code>lru_cache</code>装饰器，但是我们可以自己实现，非常简单，如下：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_CACHE_VALUES = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memoized</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> _CACHE_VALUES.get(x, func(x))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="decorator">@memoized</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addtwo</span><span class="params">(x)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>但我们上面这种写法太简单了，连缓存命中率这些统计都没有，而且也不通用。但明白了基本原理，我们要扩展也就不难了。更加复杂的装饰器实现可以参考<a href="http://ajucs.com/2016/01/14/dive-into-python-decorator.html">《深入浅出Python装饰器》</a>。<br>更偷懒一点，你可以把Python源码中的lru_cahce函数相关代码拷贝到项目中，<a href="https://github.com/python/cpython/blob/77a475ebaa65aa5a85287cbe782c552039c9f507/Lib/functools.py#L391" target="_blank" rel="external">参考这里</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="记忆化（Memoization）介绍">记忆化（Memoization）介绍</h2><p>简单说来 Memoization 是一种利用缓存来加速函数调用的技术手段，将消耗较大的调用结果存储起来，当再次遇到相同调用时就从缓存读取结果而无需重新计算。<br><strong>有一个限制条件是该函数必须是纯函数式的</strong>，相当于函数式编程中的不可变性，即输入一致时输出一定不会改变。比如计算平方的函数就满足这种条件，<code>square(3)</code> 的结果永远是<code>9</code>，所以我们才能把它的结果存储起来，下次需要知道<code>3</code>的平方的结果时，无需计算，直接从内存中读取就好了。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://ajucs.com/tags/Python/"/>
    
      <category term="性能优化" scheme="http://ajucs.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出Python装饰器]]></title>
    <link href="http://ajucs.com/2016/01/14/dive-into-python-decorator.html"/>
    <id>http://ajucs.com/2016/01/14/dive-into-python-decorator.html</id>
    <published>2016-01-14T05:52:34.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<p>有朋友说看到《Python CookBook》的装饰器部分有些迷糊，究其原因是没有清晰地理解Python装饰器是什么，能干什么。于是有了本文。看此文时，从头到尾跟着思路走，应该会对Python装饰器有更明白深刻的认识。新手不要跳读，新手不要跳读，新手不要跳读。<br>本文假定你已经明白了Python中什么叫做函数，变量的作用域、解析规则及生存周期。阿驹还是简单阐述一下：</p>
<ul>
<li><strong>作用域</strong>: 变量起作用的范围， 也称之为命名空间。以方法、类、函数、模块、包、Python内置环境(当前Python解释器的Python Path里所包含的)这几个的程序结构为单元，以<code>大结构</code>包含<code>小结构</code>，<code>外层</code>包含<code>内层</code>的方式，把变量放置在这样一个个的空间中，一个程序结构单元就对应一个作用域（命名空间）。每个变量，不加global和nonlocal关键字时，只属于声明该变量的这层作用域。<a id="more"></a></li>
<li><strong>变量解析规则</strong>: 根据上述可知，作用域是可以相互独立，也可以是相互嵌套存在的。而变量的解析，是从自身所在的作用域出发，逐层往上寻找。并不能去查找和自己独立并列的作用域。</li>
<li><strong>变量生存周期</strong>：变量随着它所在的程序结构单元（方法、类、函数、模块、包）的调用而生，随着调用结束而消。调用开始前和结束后试图操作该作用域内的变量，都将出错。</li>
</ul>
<p><strong>一定要深刻理解以上三点。一定要深刻理解以上三点。一定要深刻理解以上三点。</strong><br>在正式讲解装饰器之前解释上面三个概念的原因是装饰器就是根据这三个概念玩的花样。也是《Python之禅》中最后一句话“Namespaces are one honking great idea – let’s do more of those!”的一个具体体现。</p>
<h2 id="Python函数的特点">Python函数的特点</h2><ul>
<li>是对象，与其他对象无异，具有属性，可以作为参数传递、返回等</li>
<li>函数里可以再声明函数（嵌套）</li>
</ul>
<h2 id="函数闭包">函数闭包</h2><p>一个来自于Scheme的概念，被诸多函数式编程语言实现。也许你听说过装饰器是基于闭包实现的，那么闭包的本质是什么呢？我们先不对闭包下定义。（翠花儿，上代码！）<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">       a, b = <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">       print(<span class="string">"inner's vars sum:"</span>, a+b)</span><br><span class="line">       print(<span class="string">"use var y of outer:"</span>, y)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">f = outer()</span><br><span class="line">f()</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="string">"inner's vars sum:"</span>, <span class="number">9</span>)</span><br><span class="line">(<span class="string">'use var y of outer:'</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>仔细看上述代码。在inner中使用变量y时，根据解析规则，因为inner自己的作用域中未找到，故而到上层的outer的作用域中查找，打印的两行结果也是正确的。<br><strong>但是，但是，但是</strong>，有一个问题，我们说过变量的生存周期。不是说函数调用结束时，变量就销毁了吗？ <code>f = outer()</code> 执行完时按理说x, y, z及内部的inner函数都应当被销毁了呀？！你也许会想，调用结束时把inner返回给了<code>f</code>呀，当然能执行。思考一个问题，<code>f</code> 是 <code>inner</code> 吗？换个问法，这里等号赋值，是把<code>inner</code>的引用传递给了<code>f</code>吗？<br><code>f</code> 不是 <code>inner</code> ，因为inner只包含其def声明开始，函数体结束为止的内容，其作用域中只有a，b两个变量，在我们调用f时，却正确打印出了outer作用域中的变量。<br>似乎，<code>f</code> 是 <code>inner</code> 加上 <code>y</code> 的合体。对了，这就引出了闭包的概念，<code>f</code>是一个闭包。下面来给闭包概念做个确切的表述。</p>
<blockquote>
<p>嵌套定义在非全局作用域中的函数，当它的外部函数被调用就会生成一个闭包，闭包中包含了这个子函数本身的代码与其依赖的外部变量的引用。</p>
</blockquote>
<p>注：Python的一个py文件就是一个模块，就是一个全局作用域。闭包不是这个子函数， 而是这个子程序与其依赖的外部变量构成的整体。这个整体构成了一个新的封闭的作用域，所以叫闭包。<strong>上例中，inner子程序并没依赖外部的x和z，所以这个闭包中不包含x,z。</strong>也可以把闭包当做一个新的函数来对待，不过这个新函数的逻辑代码还是原来的子函数代码，但其作用域，却包含了原子函数的变量和其依赖的外部变量。</p>
<p><strong>另外，每次调用外部函数，其内部函数都会被重新定义，就会生成一个新的闭包。</strong> 这是同一个装饰器可以作用于不同的函数的基础。如下例，其本质不是分别传递参数1,2给inner，而是生成了两个能打印各自数字的闭包。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> x</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">print1 = outer(<span class="number">1</span>)</span><br><span class="line">print2 = outer(<span class="number">2</span>)</span><br><span class="line">print1()</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">print2()</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="“纯手工”装饰器">“纯手工”装饰器</h2><p>在上例中，我们给<code>outer</code>函数传递的参数是一个整数，然后对这个整数进行了处理（某种装饰和加强，虽然这里只是print了一下）。如果我们传递的是一个函数呢？那它就成了装饰器！我们可以在inner内部执行额外的操作，再返回一个闭包。而这个返回的闭包，就是原函数被装饰后的版本（代替加强版）。<strong>装饰器的本质就是函数闭包，或者说利用了函数闭包的特性。</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(function)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"执行function之前可以进行额外操作"</span>)</span><br><span class="line">        result = function()</span><br><span class="line">        print(<span class="string">"执行function之后还可以进行额外操作"</span>)</span><br><span class="line">        result *= <span class="number">2</span>        <span class="comment"># 对function的返回值本身进行额外操作</span></span><br><span class="line">        <span class="keyword">return</span> result      <span class="comment"># 返回‘加强’后的结果</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_for_deco</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">decorated = outer(wait_for_deco)</span><br><span class="line"><span class="keyword">print</span> decorated()</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">2048</span></span><br></pre></td></tr></table></figure></p>
<p>上例就是纯手工实现的一个最简单的装饰器。装饰器函数<code>outer</code>并没有修改被装饰函数<code>wait_for_deco</code>，但我们调用被装饰后的<code>decorated</code>函数闭包却能够得到原函数的加强版结果，还能进行额外的操作。<br>为了让返回的闭包函数看起来就像是原函数的加强版，我们只需要像下面这么做。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait_for_deco = outer(wait_for_deco)</span><br></pre></td></tr></table></figure></p>
<p>为了简化代码，Python为我们提供了装饰符<code>@</code>，只需要在<code>wait_for_deco</code>上面加上<code>@outer</code>就可以了。<strong>实际上装饰符<code>@</code>就仅仅是帮我们自动地把返回的闭包函数名字替换为原函数的名字。</strong> 使返回后的新函数(闭包)看起来就是原函数，不过是加强了的。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># outer 函数不变</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用装饰符简化代码</span></span><br><span class="line"><span class="decorator">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_for_deco</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> wait_for_deco()</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">2048</span></span><br></pre></td></tr></table></figure></p>
<p>以上，装饰器的来龙去脉就讲清楚了。但是它太简单了，被装饰的函数没有参数，装饰器也没有参数。接下来就是对装饰器进行扩展。比如写出能接受任何函数的装饰器，以及装饰器本身可以带参数，以及用类作装饰器，还有装饰器的实际应用。</p>
<h2 id="支持带参数的函数">支持带参数的函数</h2><p>刚才我们提到，装饰器最终返回的是一个闭包，而这个闭包可以看做一个函数，它是原函数的加强版。即是，调用原函数，变成了调用这个被装饰后的闭包。那么原函数的参数如果能够按原样传递给这个闭包函数的话，那么在装饰器中我们应该在其内部函数的定义中按原函数的格式写上参数。这样调用这个闭包时就可以按原来的样子传递参数了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 例如为下面的函数写一个装饰器，应该在内部的wapper中按原样传递参数</span><br><span class="line">def decorator(func):</span><br><span class="line">    def wrapper(x, y)</span><br><span class="line">      ret = func(x, y)    # 原函数的返回值</span><br><span class="line">      return ret*2        # 原函数的结果“加强”后再返回</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@decorator</span><br><span class="line">def wait_for_deco(x, y):</span><br><span class="line">  return x + y</span><br><span class="line"></span><br><span class="line">print(wait_for_deco(1, 2))</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p>按照上面这种写法虽然可以传参了但有个缺陷，参数个数不确定的函数就没法使用这个装饰器了。比如，原函数有x, y, z三个参数，也想有把结果放大两倍的装饰器呢？能写出通用装饰器吗？能。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def decorator(func):</span><br><span class="line">    def wrapper(*args, **kwargs)</span><br><span class="line">      ret = func(*args, **kwargs)</span><br><span class="line">      return ret*2</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@decorator</span><br><span class="line">def wait_for_deco_a(x, y):</span><br><span class="line">  return x + y</span><br><span class="line"></span><br><span class="line">@decorator</span><br><span class="line">def wait_for_deco_b(x, y, z):</span><br><span class="line">  return x + y + z</span><br><span class="line"></span><br><span class="line">print(wait_for_deco_a(1, 2))</span><br><span class="line">6</span><br><span class="line">print(wait_for_deco_b(1, 2, 3))</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以让装饰器装饰任何形式传参的函数了。而以上两个被装饰的原函数也可以根据任意参数的匹配来简化为一个函数，不属于本文探讨的内容了。<code>*args, **kwargs</code> 的具体使用方法和原理，这是Python基础内容，不明白的可以看《Python学习手册》作用域和参数那一章。</p>
<h2 id="装饰器带参数">装饰器带参数</h2><p>前文中讲解了，装饰符<code>@</code>只是帮我们把返回的闭包名字替换为了和原函数一样的名字。像下面这种操作：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">after_decorated = decorator(origin_func)</span><br><span class="line"><span class="string">'@'</span>符号做就是</span><br><span class="line">origin_func = decorator(origin_func) <span class="comment"># 得到的是已装饰后的闭包函数</span></span><br></pre></td></tr></table></figure></p>
<p>我们只需要记住一点，最终装饰器需要返回一个<strong>可调用的</strong>对象（闭包函数），我们才能把原函数作为第一个参数传进去。而要装饰器支持参数，类似于下面这样：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="decorator">@decorator(args)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_for_deco</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p>
<p>按照我们上面讲的<code>@</code>的作用，解释器会把上面这个带参数的装饰器像下面这样执行：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait_for_deco = decorator(args)(x, y)</span><br></pre></td></tr></table></figure></p>
<p>聪明的你已经想到了，<code>decrator(args)</code>返回的是最终需要的装饰器就好了。所以，带参数的装饰器就需要写成下面这样：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"在这里使用装饰器的name参数："</span>, name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        print(<span class="string">"在这里也可用装饰器的name参数："</span>, name)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">"这里还可使用装饰器的name参数："</span>, name)</span><br><span class="line">            ret = func(*args, **kwargs)    <span class="comment"># 这里进行原函数的计算</span></span><br><span class="line">            <span class="keyword">return</span> ret*<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> _wrapper                    <span class="comment"># 返回可调用对象，_wrapper可以接受原函数的参数</span></span><br><span class="line">    <span class="keyword">return</span> wrapper                         <span class="comment"># 返回真正的装饰器，接受原函数作为第一个参数</span></span><br><span class="line"></span><br><span class="line"><span class="decorator">@decorator('haha')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_for_deco</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p>
<h2 id="用类(class)作装饰器">用类(class)作装饰器</h2><h2 id="同时使用多个装饰器">同时使用多个装饰器</h2><h2 id="装饰器实例">装饰器实例</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>有朋友说看到《Python CookBook》的装饰器部分有些迷糊，究其原因是没有清晰地理解Python装饰器是什么，能干什么。于是有了本文。看此文时，从头到尾跟着思路走，应该会对Python装饰器有更明白深刻的认识。新手不要跳读，新手不要跳读，新手不要跳读。<br>本文假定你已经明白了Python中什么叫做函数，变量的作用域、解析规则及生存周期。阿驹还是简单阐述一下：</p>
<ul>
<li><strong>作用域</strong>: 变量起作用的范围， 也称之为命名空间。以方法、类、函数、模块、包、Python内置环境(当前Python解释器的Python Path里所包含的)这几个的程序结构为单元，以<code>大结构</code>包含<code>小结构</code>，<code>外层</code>包含<code>内层</code>的方式，把变量放置在这样一个个的空间中，一个程序结构单元就对应一个作用域（命名空间）。每个变量，不加global和nonlocal关键字时，只属于声明该变量的这层作用域。]]>
    
    </summary>
    
      <category term="Python" scheme="http://ajucs.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python入门、基础书籍简评与推荐]]></title>
    <link href="http://ajucs.com/2015/12/21/getting-started-with-python-books.html"/>
    <id>http://ajucs.com/2015/12/21/getting-started-with-python-books.html</id>
    <published>2015-12-21T06:33:34.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<p>本文对Python网友讨论较多的几本基础入门书籍做个简评，给新手朋友们一个参考。本文仅代表阿驹的个人对它们的意见，不一定完全正确，但站在阿驹的角度看来，是很中肯的。</p>
<h3 id="《简明Python教程》">《简明Python教程》</h3><ul>
<li>英文原版名为《A Byte of Python》。它非常简明扼要地介绍了Python语言基础的各个方面。</li>
<li>适合群体：<ol>
<li>仅仅临时使用Python的新手，非专业性地临时运用十来行简单代码就能自动化处理一些工作。</li>
<li>非常熟练编程的老手，深谙编程本质，换语言不过是换工具而已，通过简要地提点，其他诸多方面自然通晓，辅以浏览官方文档和《Python Cookbook》此类书籍，就和Python熟手无异。<a id="more"></a>
</li>
</ol>
</li>
</ul>
<h3 id="《Python基础教程》">《Python基础教程》</h3><ul>
<li>英文原版名为《Beginning Python: from Novice to Professional》，直译过来可以叫《Python入门：从新手到专业》。从如何安装Python运行环境，到一些计算机程序专业术语的解释，再到Python基本数据结构、语法的讲解，再到面向对象程序设计基础， 再是IO、GUI、数据库、网络编程、程序测试、Web开发， Python的C、Java、C#扩展的介绍。还有几个小的练习项目。<br>中规中矩的目录结构与基础体系介绍，像网络、IO、GUI及其之后的章节都是浅尝辄止。但有一定的宽度，对Python进行了较为广泛地涉猎。</li>
<li>适合群体:<ol>
<li>计算机相关专业学生(应该是面对各项专业科目考试都应付自如的水平)，混日子的学生就不要把自己划为此列了。</li>
<li>有对编程有较为正确认知的人，比如偶尔要写写小脚本的运维人员，需要更全面掌握Python的。</li>
</ol>
</li>
</ul>
<h3 id="《Python核心编程》">《Python核心编程》</h3><ul>
<li>我初览此书的第一印象：较为全面，由浅入深，也不是很深，比上述基础教程深些。其第一章介绍Python时就谈及程序的健壮性、可移植性、快速原型开发、Python与其他语言的比较，可见并不是为0基础，也不是为编程初学者准备的。<br>再是第二印象，对中文版的:翻译不妥当的地方较多，印刷错误较多。加之中文内容大多数都来自网络社区，而“译者”只署自己一人之名的行径确实有待商榷。既然内容来自网络社区，那么，翻译的水平自然是参差不齐，读起来觉得行文风格不一的怪异也就难免了。故而不推荐中文版。<br>原版倒是针对有编程经验的同学很有帮助。</li>
<li>适合群体：<ol>
<li>英语阅读能力良好的有其他语言实践编程经验（非学校二三十行的家庭作业）的人，并期望较为熟练掌握Python运用于自己实际工程项目。</li>
</ol>
</li>
</ul>
<h3 id="《Python学习手册》">《Python学习手册》</h3><ul>
<li>详细，详细，详细。对Python语言基础（不含标准库）进行了非常详细地介绍与深入剖析，让你明白Python语言基础中“是什么”，“为什么”，“怎么样”。其内容包括什么是动态语言，什么是函数，什么是类，如何设计类，如何设计模块，什么是异常与处理异常……</li>
<li>适合群体：<ol>
<li>0基础，对新事物接受能力较强，需要真的有耐心咀嚼书中内容，并动手实践练习的人。</li>
<li>有任何层次的编程基础，也希望明白Python语言各个细节“为什么是那样”的人。</li>
</ol>
</li>
</ul>
<h3 id="《像计算机科学家一样思考Python》">《像计算机科学家一样思考Python》</h3><ul>
<li>第一章就告诉了你程序的本质，什么是调试，如何调试，什么是运行时错误，什么是语法错误。后续章节开始介绍了Python的基本数据类型，Python代码如何编写，接口应该怎么设计，对面向对象编程也进行了专业的讲解，另外附带Tkinter GUI编程的介绍。<br>这本书从专业地角度引导读者学习Python，像在介绍列表之类的基本数据类型，还会阐明它为什么会这样，在内存中会怎样，Python为何这样实现，以及在介绍数据结构的同时附带介绍了和数据结构相关的一些算法。</li>
<li>适合群体：<ol>
<li>程序设计理论知识相当扎实的学生；</li>
<li>程序设计理论知识匮乏及对算法在程序中的运用理解浅显的在职编程人员。</li>
</ol>
</li>
</ul>
<h3 id="《Python_Cookbook》">《Python Cookbook》</h3><ul>
<li>Python实践运用中相当多的操作技巧，这些都是可以直接运用于工程项目中的，涉及Python的各方面。</li>
<li>适合群体:<ol>
<li>掌握了Python基础，实践过程中感觉自己能力尚有欠缺的人。</li>
</ol>
</li>
</ul>
<h3 id="《深入理解Python》">《深入理解Python》</h3><ul>
<li>英文原版名为《Dive Into Python》。从零零散散地各个方面说明的强大功能或者是更好的一些细节技巧，比如and和or运算如何优化之类的。不过此书不太推荐，老了，网络翻译也一般，深度也不如《Pytho Cookbook》和《Effective Python: 59 Specific Ways to Write Better Python》。《编写高质量代码:改善Python程序的91个建议》这本网络博文搜集整理的书籍就是拾”DIP”和”EP”这两本书的牙慧。</li>
<li>适合群体：<ol>
<li>掌握了Python基础，想要写出更Pythonic代码的人。记住，阿驹实际上已经推荐的是《Effective Python》了。</li>
</ol>
</li>
</ul>
<h3 id="《深入浅出Python》">《深入浅出Python》</h3><ul>
<li>英文原版名为《Head First Python》, “Head First”系列书籍封面阿驹一眼看上去太cute了，感觉不是自己的菜，所以此系列书籍几乎很少阅读。至于Python这本，粗略浏览了一下，有基础介绍，但会从基础引导读者思考在工程实践中可能的运用。</li>
<li>适合群体：<ol>
<li>最好有计算机专业基础和一门较为熟练的编程语言，初入职场从事Python编程的同学应该会有所用。</li>
</ol>
</li>
</ul>
<h3 id="《笨办法学Python》">《笨办法学Python》</h3><ul>
<li>以输入是什么，运行程序，在屏幕上输出结果应该是什么这样的方式来教学。算是手把手之类的教学。以Python语言基础为主。书后“怎么学习任何一门编程语言”这节，没有编程基础的新手应该看看。</li>
<li>适合群体：<ol>
<li>编程0基础的，但有自学能力的。</li>
<li>程序设计上你可以是0基础，但对计算机和软件的认识不能是0基础，至少，应该对中小学计算机教材基础里面提到的知识点都知其然知其一些所以然。</li>
</ol>
</li>
</ul>
<h3 id="其他">其他</h3><p>以下书籍没有去认真了解过，连目录、前言、以及开始章节都没仔细研究过，也就不评了。不过我觉得，真的是对计算机和编程一窍不通，只是为了了解编程而学习的人，可以看看以下书籍，找一本自己喜欢的。</p>
<ul>
<li>《可爱的Python》</li>
<li>《父与子的编程之旅:与小卡特一起学Python》</li>
<li>《趣学Python》</li>
<li>《与孩子一起学编程》</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文对Python网友讨论较多的几本基础入门书籍做个简评，给新手朋友们一个参考。本文仅代表阿驹的个人对它们的意见，不一定完全正确，但站在阿驹的角度看来，是很中肯的。</p>
<h3 id="《简明Python教程》">《简明Python教程》</h3><ul>
<li>英文原版名为《A Byte of Python》。它非常简明扼要地介绍了Python语言基础的各个方面。</li>
<li>适合群体：<ol>
<li>仅仅临时使用Python的新手，非专业性地临时运用十来行简单代码就能自动化处理一些工作。</li>
<li>非常熟练编程的老手，深谙编程本质，换语言不过是换工具而已，通过简要地提点，其他诸多方面自然通晓，辅以浏览官方文档和《Python Cookbook》此类书籍，就和Python熟手无异。]]>
    
    </summary>
    
      <category term="Python" scheme="http://ajucs.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单明了地选择Python GUI库]]></title>
    <link href="http://ajucs.com/2015/12/08/how-to-choose-python-GUI-toolkit-library.html"/>
    <id>http://ajucs.com/2015/12/08/how-to-choose-python-GUI-toolkit-library.html</id>
    <published>2015-12-08T08:40:50.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<p>可用于Python GUI程序开发，优秀且更新“跟得上时代”的库有 <strong>wxPython</strong> 、<strong>PyQT</strong>(PySide)、<strong>Kivy</strong>  、<strong>Libavg</strong> ，当然还有 Python 内置的 <strong>Tkinter</strong> 。像 PyGUI 、PyGTK 、PySWT 等，由于上次更新距现在太为久远且文档、学习资料、稳定性等诸多考虑，阿驹认为它们并不适合于开发一个正式的项目，就不作介绍。</p>
<h2 id="各种_Python_GUI_库简介">各种 Python GUI 库简介</h2><h3 id="1-_wxPython">1. wxPython</h3><ul>
<li>跨平台，Windows / Unix / unix-like / OS X</li>
<li>包装的是 <a href="http://wxwidgets.org/" target="_blank" rel="external">wxWidgets</a>，C++写成的</li>
<li>完全开源，可以任意用于自己的开源或商业项目</li>
<li>不支持 Python3.x （新启了一个名为 Phoenix 项目，支持 Python 3.x，尚未正式发布）</li>
<li>学习资料《wxPython in Action》、《wxPython 2.8 Application Development Cookbook》，均有中文版</li>
<li>有第三方提供的图形化界面设计工具，但还是有瑕疵，不如PyQT的强大</li>
<li>看起来非常本地化地界面<a id="more"></a>
</li>
</ul>
<h3 id="2-_PyQT">2. PyQT</h3><ul>
<li>跨平台</li>
<li>对QT的包装，QT也是C++实现的</li>
<li>多种授权协议可选，若要开发商业软件，需要花钱购买商业授权</li>
<li>有自带的功能强大的图形界面设计工具</li>
<li>支持Python 2 &amp; 3</li>
<li>缺乏成体系的中文学习资料，英文资料足够丰富</li>
<li>QT 的内存模型和 Python 的内存模型不一致，使用不当可能会导致内存泄露</li>
<li>打包后的程序体积较为庞大</li>
</ul>
<h3 id="3-_Tkinter">3. Tkinter</h3><ul>
<li>Python内置GUI库</li>
<li>简单易用</li>
<li>功能性较 PyQT 和 wxPython 差很多</li>
<li>支持Python 2 &amp; 3</li>
<li>有第三方提供的图形化界面设计工具</li>
<li>有一定量的中文学习资料，英文资料足够丰富</li>
<li>看起来不那么本地化地界面</li>
</ul>
<h3 id="4-_Libavg">4. Libavg</h3><ul>
<li>跨平台</li>
<li>用于以多媒体（图象、文本、音频、视频、数码输出、矢量制图）为主的GUI程序开发高级库（“高级”二字在计算机文档中，通常指相对于“计算机/软件底层”来说的一种抽象概念，“高级”绝不等同于“功能更强，高大上”）</li>
<li>支持多点触控、手势识别的系统和设备</li>
<li>基于LGPL协议</li>
<li>支持Python 2 &amp; 3</li>
<li>几乎没有中文学习资料，英文学习资料也较少，就官方文档较为丰富</li>
</ul>
<h3 id="5-_Kivy">5. Kivy</h3><ul>
<li>跨平台，除了PC机平台，还支持<strong>Android / iOS / Raspberry Pi</strong></li>
<li>支持多点触控</li>
<li>核心基于OpenGL ES2，可利用GPU加速</li>
<li>支持Python 2 &amp; 3，不过Python 3的还不那么完善，如果要用于iOS和Android的开发，使用Python 2.7</li>
<li>中文学习资料非常少，英文文档足够丰富</li>
</ul>
<h2 id="如何选择GUI库">如何选择GUI库</h2><ul>
<li>新手，仅仅像尝尝Python GUI编程的乐趣： Tkinter</li>
<li>想开发基于PC，功能复杂的商业项目，愿意花钱购买版权： PyQT</li>
<li>想开发基于PC，功能复杂的商业项目，不愿意花钱购买版权，考虑Python3支持： Kivy</li>
<li>想开发基于PC，功能复杂的商业项目，不愿意花钱购买版权，暂不考虑Python3，要有良好的本地化表现： wxPython</li>
<li>想开发基于PC，功能强大，能快速可视化设计的开源软件：PyQT</li>
<li>想开发基于PC，功能复杂的软件，阅读英文资料非常吃力： wxPython</li>
<li>想开发移动应用，掌上游戏之类的：Kivy</li>
<li>想开发丰富的多媒体软件：Libavg</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>可用于Python GUI程序开发，优秀且更新“跟得上时代”的库有 <strong>wxPython</strong> 、<strong>PyQT</strong>(PySide)、<strong>Kivy</strong>  、<strong>Libavg</strong> ，当然还有 Python 内置的 <strong>Tkinter</strong> 。像 PyGUI 、PyGTK 、PySWT 等，由于上次更新距现在太为久远且文档、学习资料、稳定性等诸多考虑，阿驹认为它们并不适合于开发一个正式的项目，就不作介绍。</p>
<h2 id="各种_Python_GUI_库简介">各种 Python GUI 库简介</h2><h3 id="1-_wxPython">1. wxPython</h3><ul>
<li>跨平台，Windows / Unix / unix-like / OS X</li>
<li>包装的是 <a href="http://wxwidgets.org/">wxWidgets</a>，C++写成的</li>
<li>完全开源，可以任意用于自己的开源或商业项目</li>
<li>不支持 Python3.x （新启了一个名为 Phoenix 项目，支持 Python 3.x，尚未正式发布）</li>
<li>学习资料《wxPython in Action》、《wxPython 2.8 Application Development Cookbook》，均有中文版</li>
<li>有第三方提供的图形化界面设计工具，但还是有瑕疵，不如PyQT的强大</li>
<li>看起来非常本地化地界面]]>
    
    </summary>
    
      <category term="GUI" scheme="http://ajucs.com/tags/GUI/"/>
    
      <category term="Kivy" scheme="http://ajucs.com/tags/Kivy/"/>
    
      <category term="PyQT" scheme="http://ajucs.com/tags/PyQT/"/>
    
      <category term="Python" scheme="http://ajucs.com/tags/Python/"/>
    
      <category term="wxPython" scheme="http://ajucs.com/tags/wxPython/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python web 加密下载链接的实现]]></title>
    <link href="http://ajucs.com/2015/12/03/implemention-of-encrypt-download-links.html"/>
    <id>http://ajucs.com/2015/12/03/implemention-of-encrypt-download-links.html</id>
    <published>2015-12-03T10:22:28.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<h2 id="需求背景">需求背景</h2><p>文件上传下载绝对是Web攻防中一个重要的突破口。网络安全日益受重视的今天，web开发中除了要对文件上传进行严格的权限控制，文件下载亦是如此。不可随意暴露服务器端信息，以及用户信息。<br>其他技术栈的网站也可以作参考。</p>
<h2 id="实例">实例</h2><p>设有银行网站 WEB_SERVER , 另有银行每月交易流水日志文件服务器 LOG_SERVER , 用户在 BANK_WEB 的 “个人中心” 里可以 “下载流水日志”。<br>用户点击 “下载流水日志” 后，选择想要流水日志的年月，WEB_SERVER 返回的是一个加密的下载链接，此链接可以由浏览器当时执行，也可放在下载工具中下载。也有如下安全性要求。</p>
<ul>
<li>用户无法构造文件的URL</li>
<li>不直接暴露文件的绝对路径</li>
<li>开始下载之前不暴露文件名</li>
<li>可以进行权限控制，无权限者无法下载</li>
<li>下载链接有过期时间</li>
<li>还可以实现其他你可以想到的功能</li>
<li>文件下载服务器只需提供文件，无须管理用户信息<a id="more"></a>
</li>
</ul>
<h2 id="具体实现">具体实现</h2><ol>
<li><p>设计URL<br>如下形式的URL作为下载链接给用户：</p>
 <figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://file.logserver.com/<span class="variable">$ENC</span>_MSG</span><br></pre></td></tr></table></figure>
<p>其中，<code>$ENC_MSG</code>是一条加密消息。由于需要真实的文件信息、用户权限信息、过期信息等都需要从加密消息中解密出来，所以加密算法必须时<strong>可逆且可靠的</strong>。我们采用<strong>AES</strong>加密算法。</p>
</li>
<li><p>生成作为AES加密key的字符串<br>主要利用用户留在<code>WEB_SERVER</code>服务端的私密信息（无法公开获得或构造）生成， 由于AES解密时需要相同的key，故此key应该可以再次计算出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line">key = hmac.new(</span><br><span class="line">    account+secret,</span><br><span class="line">    <span class="string">'|'</span>.join([user_id, reg_time, account_id]),</span><br><span class="line">    hashlib.sha1</span><br><span class="line">).hexdigest()[:<span class="number">32</span>]    <span class="comment"># AES的key最长接受32字节(256 bit)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成加密消息 $ENC_MSG<br>AESCipher类基于pycrypto库的AES类实现, 可以参考此实现在AES加密解密过程中添加额外的处理。比如我们增加了一层base64算法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto <span class="keyword">import</span> Random</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AESCipher</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.bs = <span class="number">32</span></span><br><span class="line">        self.key = key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encrypet</span><span class="params">(self, raw)</span>:</span></span><br><span class="line">        raw = self._pad(raw.encode(<span class="string">'UTF-8'</span>))</span><br><span class="line">        iv = Random.new().read(AES.block_size)</span><br><span class="line">        cipher = AES.new(self.key, AES.MODE_CBC, iv)</span><br><span class="line">        <span class="keyword">return</span> base64.b64encode(iv + cipher.encrypt(raw))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(self, enc)</span>:</span></span><br><span class="line">        enc = base64.b64decode(enc)</span><br><span class="line">        iv = enc[:AES.block_size]</span><br><span class="line">        cipher = AES.new(self.key, AES.MODE_CBC, iv)</span><br><span class="line">        <span class="keyword">return</span> self._unpad(cipher.decrypt(enc[AES.block_size:])).decode(<span class="string">'UTF-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_pad</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_unpad</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s[:-ord(s[len(s)-<span class="number">1</span>:])]</span><br><span class="line"></span><br><span class="line">enc_msg = AESCipher(key).encrypet(</span><br><span class="line">    <span class="string">'|'</span>.join([user_id, account_id, month, log_type, expire]))</span><br></pre></td></tr></table></figure>
</li>
<li><p>将以上URL提供给用户供用户下载，用户向文件服务器 LOG_SERVER 发起请求</p>
</li>
<li>文件服务器先从URL中提取出加密消息，转发给 WEB_SERVER 并等待其反会结果</li>
<li>WEB_SERVER得到加密消息，解密，获得用户信息，进行各项参数的合法性校验<br>WEB_SERVER 按照上面的加密方式，构造出相同的key，解密 $ENC_MSG , 得到 user_id, account_id, month, log_type, expire 几个参数。<br>user_id: 用户身份标识，可以校验用户是否具有某种条件，如日志下载权限<br>account_id: 账户标识，可以检查该账户是否具有某种条件<br>month: 要下载日志的月份，如201511<br>log_type: 日志类型，或者是文件基于某种特征的分类<br>expire：过期时间的unix时间戳，和当前时间对比，看是否该下载链接已经过期</li>
<li><p>如果校验通过，WEB_SERVER 则构造合法的日志文件路径，将此路径写入 HTTP 头的 <code>X-Accel-Redirec</code> 字段返回给文件服务器。例如：</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Accel-Redirect: /logs/<span class="number">62111644023456868108</span>/custom-<span class="number">201511</span><span class="class">.log</span><span class="class">.gz</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件服务器收到该响应后，输出真实文件给用户</p>
</li>
</ol>
<h2 id="交互时序图">交互时序图</h2><p><img src="http://7xn3rj.com1.z0.glb.clouddn.com/static/images/encryption-download-url.png" alt="加密下载链接交互时序图"></p>
<h2 id="扩展思考">扩展思考</h2><ul>
<li>如何生成一次性加密下载链接</li>
<li>如何更有效地隐藏文件服务器的真实地址</li>
<li>用户直接构造最终的真实文件URL来访问文件地址怎么办</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="需求背景">需求背景</h2><p>文件上传下载绝对是Web攻防中一个重要的突破口。网络安全日益受重视的今天，web开发中除了要对文件上传进行严格的权限控制，文件下载亦是如此。不可随意暴露服务器端信息，以及用户信息。<br>其他技术栈的网站也可以作参考。</p>
<h2 id="实例">实例</h2><p>设有银行网站 WEB_SERVER , 另有银行每月交易流水日志文件服务器 LOG_SERVER , 用户在 BANK_WEB 的 “个人中心” 里可以 “下载流水日志”。<br>用户点击 “下载流水日志” 后，选择想要流水日志的年月，WEB_SERVER 返回的是一个加密的下载链接，此链接可以由浏览器当时执行，也可放在下载工具中下载。也有如下安全性要求。</p>
<ul>
<li>用户无法构造文件的URL</li>
<li>不直接暴露文件的绝对路径</li>
<li>开始下载之前不暴露文件名</li>
<li>可以进行权限控制，无权限者无法下载</li>
<li>下载链接有过期时间</li>
<li>还可以实现其他你可以想到的功能</li>
<li>文件下载服务器只需提供文件，无须管理用户信息]]>
    
    </summary>
    
      <category term="Python" scheme="http://ajucs.com/tags/Python/"/>
    
      <category term="Web" scheme="http://ajucs.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[修复pip升级后pip与pip3命令均安装三方包至python3目录下]]></title>
    <link href="http://ajucs.com/2015/11/26/fix-pip-to-python2-after-upgrade-pip3.html"/>
    <id>http://ajucs.com/2015/11/26/fix-pip-to-python2-after-upgrade-pip3.html</id>
    <published>2015-11-26T09:27:10.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<h2 id="状况描述">状况描述</h2><p>目前安装好较新的 Linux 发行版后，系统默认已经安装好了 python2 与 python3 。有时，也需要在这两种 python 环境下方便地安装python包。而根据 <a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="external">pip的安装文档</a> 安装好了pip以后，默认情况下是安装在python2下面的（因为Linux默认的python版本是2）。</p>
<p>然而我们再执行 <code>python3 get-pip.py</code> 来为 python3 装好pip后，我们发现如下情况：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>pip -<span class="constant">V</span></span><br><span class="line">pip <span class="number">7.1</span>.<span class="number">2</span> from /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">python3</span>.4/<span class="title">dist</span>-<span class="title">packages</span> (<span class="title">python</span> 3.4)</span></span><br><span class="line"><span class="variable">$ </span>pip3 -<span class="constant">V</span></span><br><span class="line">pip <span class="number">7.1</span>.<span class="number">2</span> from /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">python3</span>.4/<span class="title">dist</span>-<span class="title">packages</span> (<span class="title">python</span> 3.4)</span></span><br><span class="line"><span class="variable">$ </span>pip2 -<span class="constant">V</span></span><br><span class="line">pip <span class="number">7.1</span>.<span class="number">2</span> from /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">python2</span>.7/<span class="title">dist</span>-<span class="title">packages</span> (<span class="title">python</span> 2.7)</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><code>pip</code> 与 <code>pip3</code> 都是在 python3 目录下，那么执行 <code>pip install packagename</code> 和 <code>pip3 install packagename</code> 都会把 package 安装至 python3 的环境中去。</p>
<h2 id="解决办法">解决办法</h2><p>使用如下命令重新安装一次pip：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">sudo</span> <span class="comment">pip2</span> <span class="comment">install</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">upgrade</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">force</span><span class="literal">-</span><span class="comment">reinstall</span> <span class="comment">pip</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>pip -<span class="constant">V</span></span><br><span class="line">pip <span class="number">7.1</span>.<span class="number">2</span> from /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">python2</span>.7/<span class="title">dist</span>-<span class="title">packages</span> (<span class="title">python</span> 2.7)</span></span><br><span class="line"><span class="variable">$ </span>pip3 -<span class="constant">V</span></span><br><span class="line">pip <span class="number">7.1</span>.<span class="number">2</span> from /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">python3</span>.4/<span class="title">dist</span>-<span class="title">packages</span> (<span class="title">python</span> 3.4)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="开始就该更轻松">开始就该更轻松</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install <span class="keyword">python3</span>-pip</span><br><span class="line">$ sudo apt-<span class="built_in">get</span> install <span class="keyword">python</span>-pip</span><br></pre></td></tr></table></figure>
<p>按照以上命令安装好pip以后，自然应该是pip对应在python2目录下，pip3对应在python3下的。注意先安装3的，后安装2的，因为这种方式安装pip的时候，后安装的都会将先安装的 <code>pip</code> 覆盖掉。不过这种方式安装的pip不一定是最新稳定版本的。需要自己再更新。如果不慎更新除了问题，参考上面的解决方式。</p>
<h2 id="最轻松的方式">最轻松的方式</h2><p>请一开始就使用 <code>pyenv</code> 和 <code>virtualenv</code> 工具来为不同的项目生成不同的python版本及相互隔离的虚拟环境。这样每个项目的python版本及其依赖的第三方包都不相关联。</p>
<p>参考<a href="http://www.cnblogs.com/npumenglei/p/3719412.html" target="_blank" rel="external">用pyenv 和 virtualenv 搭建单机多版本python 虚拟开发环境</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="状况描述">状况描述</h2><p>目前安装好较新的 Linux 发行版后，系统默认已经安装好了 python2 与 python3 。有时，也需要在这两种 python 环境下方便地安装python包。而根据 <a href="https://pip.pypa.io/en/stable/installing/">pip的安装文档</a> 安装好了pip以后，默认情况下是安装在python2下面的（因为Linux默认的python版本是2）。</p>
<p>然而我们再执行 <code>python3 get-pip.py</code> 来为 python3 装好pip后，我们发现如下情况：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>pip -<span class="constant">V</span></span><br><span class="line">pip <span class="number">7.1</span>.<span class="number">2</span> from /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">python3</span>.4/<span class="title">dist</span>-<span class="title">packages</span> (<span class="title">python</span> 3.4)</span></span><br><span class="line"><span class="variable">$ </span>pip3 -<span class="constant">V</span></span><br><span class="line">pip <span class="number">7.1</span>.<span class="number">2</span> from /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">python3</span>.4/<span class="title">dist</span>-<span class="title">packages</span> (<span class="title">python</span> 3.4)</span></span><br><span class="line"><span class="variable">$ </span>pip2 -<span class="constant">V</span></span><br><span class="line">pip <span class="number">7.1</span>.<span class="number">2</span> from /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">python2</span>.7/<span class="title">dist</span>-<span class="title">packages</span> (<span class="title">python</span> 2.7)</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://ajucs.com/tags/Linux/"/>
    
      <category term="Python" scheme="http://ajucs.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git合并多个提交commits]]></title>
    <link href="http://ajucs.com/2015/11/11/git-merge-multiple-commits.html"/>
    <id>http://ajucs.com/2015/11/11/git-merge-multiple-commits.html</id>
    <published>2015-11-11T08:18:35.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<p>阿驹的工作和个人项目都使用Git作为版本控制工具。与Subversion相比，Git更具Geek范，熟练之后感觉灵活强大。</p>
<p>在我们针对某个功能多次commit提交代码以后，很可能会希望将这多个commit合并为一个，再向master分支提MR（Merge Request, GitLab这样称呼；Github称为Pull Request）。<br><a id="more"></a><br>例如有如下几个commit（git log命令查看）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">commit f7fd31b1f98246f6c2d3c71f132e753d920d7284</span><br><span class="line">Author: aju &lt;aju@ajucs.com&gt;</span><br><span class="line">Date:   Wed Nov <span class="number">11</span> <span class="number">16</span>:<span class="number">32</span>:<span class="number">43</span> <span class="number">2015</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    马老板亲自确定首页不用放情趣用品</span><br><span class="line"></span><br><span class="line">commit d875ff1692afcb355c7a29887c7279b17dcfa80f</span><br><span class="line">Author: aju &lt;aju@ajucs.com&gt;</span><br><span class="line">Date:   Wed Nov <span class="number">11</span> <span class="number">16</span>:<span class="number">31</span>:<span class="number">59</span> <span class="number">2015</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    产品经理说还是放在醒目位置可以赚眼球</span><br><span class="line"></span><br><span class="line">commit <span class="number">63e2</span>abd652af32b2f02e13730fb10e5c0a21532d</span><br><span class="line">Author: aju &lt;aju@ajucs.com&gt;</span><br><span class="line">Date:   Wed Nov <span class="number">11</span> <span class="number">16</span>:<span class="number">31</span>:<span class="number">13</span> <span class="number">2015</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    项目经理说情趣用品不必放在首页醒目位置</span><br><span class="line"></span><br><span class="line">commit <span class="number">32</span>db1a7e119f09726732936c0dd64714680a172f</span><br><span class="line">Author: aju &lt;aju@ajucs.com&gt;</span><br><span class="line">Date:   Wed Nov <span class="number">11</span> <span class="number">16</span>:<span class="number">30</span>:<span class="number">37</span> <span class="number">2015</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    网站首页按双十一活动全新改版</span><br></pre></td></tr></table></figure></p>
<p>你崩溃了没？这时候我们就希望把前三个commit合并为一个，向上游分支提MR的时候只有 “网站首页按双十一活动全新改版” 与合并后的那个commit， 共两个，而不是杂乱的四个。而且上面三次提交中代码的改动也都融合到这个commit中。</p>
<h2 id="第1步：$_git_rebase_-i_&lt;不变动的commit的SHA-1&gt;">第1步：$ git rebase -i &lt;不变动的commit的SHA-1&gt;</h2><p><code>$ git rebase -i 32db1a7e119f09726732936c0dd64714680a172f</code></p>
<p>按Enter键后进入编辑状态。</p>
<h2 id="第2步：squash_或_fixup">第2步：squash 或 fixup</h2><p>进入编辑状态后，看到下面的视图。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pick</span> 63e2abd 项目经理说情趣用品不必放在首页醒目位置</span><br><span class="line">pick d875ff1 产品经理说还是放在醒目位置可以赚眼球</span><br><span class="line">pick f7fd31b 马老板亲自确定首页不用放情趣用品</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 32db1a7..f7fd31b onto 32db1a7</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#  p, pick = use commit</span></span><br><span class="line"><span class="comment">#  r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment">#  e, edit = use commit, but stop for amending</span></span><br><span class="line"><span class="comment">#  s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment">#  f, fixup = like "squash", but discard this commit's log message</span></span><br><span class="line"><span class="comment">#  x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure></p>
<p>然后将<code>d875ff1</code> 与 <code>d875ff1</code> (后两行commit) 前面的 <code>pick</code> 改为 <code>squash</code> 或者是 <code>fixup</code>，这里我们使用 <code>squash</code> 。</p>
<p><code>fixup</code>会自动将当前commit与<strong>前一个</strong>合并，并放弃当前commit的注释等内容，退出当前编辑状态就结束操作了。而使用 <code>squash</code> 当退出当前编辑状态后，会进入新的编辑状态，允许我们再次编辑注释等提交信息，再次退出才结束操作。</p>
<p>然后输入<code>:wq</code> 退出当前编辑状态（Vim编辑器的操作）。</p>
<h2 id="第3步：填写新的commit信息">第3步：填写新的commit信息</h2><p>紧接着上一步后，会进入如下视图：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># This is a combination of 3 commits.</span></span><br><span class="line"><span class="preprocessor"># The first commit's message is:</span></span><br><span class="line">项目经理说情趣用品不必放在首页醒目位置</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># This is the 2nd commit message:</span></span><br><span class="line"></span><br><span class="line">产品经理说还是放在醒目位置可以赚眼球</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># This is the 3rd commit message:</span></span><br><span class="line"></span><br><span class="line">马老板亲自确定首页不用放情趣用品</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Please enter the commit message for your changes. Lines starting</span></span><br><span class="line"><span class="preprocessor"># with '#' will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># Date:      Wed Nov 11 16:31:13 2015 +0800</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># rebase in progress; onto 32db1a7</span></span><br><span class="line"><span class="preprocessor"># You are currently editing a commit while rebasing branch 'master' on '32db1a7'.</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># Changes to be committed:</span></span><br><span class="line"><span class="preprocessor">#       modified:   index.html</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以删除里面的所有内容（或者只删除 # Please enter之前的所有内容），在第一行留下一句提交注释 <code>马老板亲自拍板首页不放情趣用品</code> 。然后 <code>:wq</code> 退出，合并就完毕了。</p>
<p>然后我们再用 <code>git log</code> 查看，只剩下两个commit了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commit <span class="number">47</span>c72892ee29dc51a8a55345fd4836893dfe12fb</span><br><span class="line">Author: aju &lt;aju@ajucs.com&gt;</span><br><span class="line">Date:   Wed Nov <span class="number">11</span> <span class="number">16</span>:<span class="number">31</span>:<span class="number">13</span> <span class="number">2015</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    马老板亲自拍板首页不放情趣用品</span><br><span class="line"></span><br><span class="line">commit <span class="number">32</span>db1a7e119f09726732936c0dd64714680a172f</span><br><span class="line">Author: aju &lt;aju@ajucs.com&gt;</span><br><span class="line">Date:   Wed Nov <span class="number">11</span> <span class="number">16</span>:<span class="number">30</span>:<span class="number">37</span> <span class="number">2015</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    网站首页按双十一活动全新改版</span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料">参考资料</h3><p><a href="http://zerodie.github.io/blog/2012/01/19/git-rebase-i/" target="_blank" rel="external">如何合併多個commits</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>阿驹的工作和个人项目都使用Git作为版本控制工具。与Subversion相比，Git更具Geek范，熟练之后感觉灵活强大。</p>
<p>在我们针对某个功能多次commit提交代码以后，很可能会希望将这多个commit合并为一个，再向master分支提MR（Merge Request, GitLab这样称呼；Github称为Pull Request）。<br>]]>
    
    </summary>
    
      <category term="git" scheme="http://ajucs.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字符编码及Python中文处理精解]]></title>
    <link href="http://ajucs.com/2015/11/10/Python-character-encoding-explained.html"/>
    <id>http://ajucs.com/2015/11/10/Python-character-encoding-explained.html</id>
    <published>2015-11-10T10:33:09.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<h2 id="本文目的">本文目的</h2><p>为 Python 程序员简练地介绍字符编码相关支持，彻底解疑“ Python 中文乱码”，“ Python 2与 Python 3 字符编码差异”等相关问题。使用其他语言的程序员可作参考，道理都是相通的，不过具体处理方式不同罢了。</p>
<h2 id="痛苦的根源">痛苦的根源</h2><ul>
<li><p><strong>起因</strong><br>计算机不能直接识别<strong>字符</strong>（文本的最小组成单位）。</p>
<ul>
<li>字形：<br>字的形状，又叫字图。文字的抽象形状，“小短横线”就是汉字“一”的字形。</li>
<li>字符：<br>抽象符号和数字成对编码用于在计算机系统中表示的信息单位。虽然字符本身是抽象的，但它一旦存在于计算机系统中，它就对应了某种特定字符编码方式。字符“一”在GBK编码中是0xD2BB。</li>
<li>字体：<br>字的形体。草书、行书、楷书，都叫字体。计算机中的字体如：华文行楷，微软雅黑。</li>
</ul>
</li>
<li><p><strong>解决办法</strong><br>但是计算机可以识别二进制数，于是采用一个二进制数来指代一个<strong>字符</strong>。</p>
<a id="more"></a></li>
<li><strong>结果</strong><br>很多人都想到了这个解决办法。比如拉丁字母，他们想到了用十进制65来表示字符’A’。不同国家或者不同组织，他们因为事先没有商量，都用了同一个整数来表示他们自己国家里的某个文字。在不相互沟通的时候相安无事，但相互沟通时，就出现了问题。</li>
</ul>
<h2 id="编码与解码">编码与解码</h2><p>  先记住，任何信息，存放在存储介质中时，都是二进制流（比特流）。</p>
<ul>
<li><strong>编码过程</strong>： 字符转换成二进制流表示的过程。</li>
<li><strong>解码过程</strong>： 二进制流转换成字符的过程。</li>
<li><strong>编码规则</strong>： 编码和解码过程中遵循的规则，例如GBK编码，UTF-8编码。</li>
</ul>
<h2 id="字符编码的来龙去脉">字符编码的来龙去脉</h2><h3 id="ASCII">ASCII</h3><p>  美国信息交换标准代码，最早的通用编码方案。开始时，只用7个比特位就表示完了所有拉丁文字母和一些符号，共128个。后来发现不够用，又启用了第8位，刚好一个字节的长度，共256个字符。</p>
<p>  但是，不同的公司/组织把这扩展出来的128个<strong>码位</strong>指派给了不同的字符，文档交流就困难了。于是ANSI这个组织站出来了，制定了ANSI标准。</p>
<p>  而且人们也发现，ASCII这种单字节（因为它占8个比特位）编码满足不了更多的字符需求，那必须得用多个字节编码。多字节字符集（MBCS）概念就诞生了。</p>
<h3 id="ANSI">ANSI</h3><p>  美国国家标准协会认可的标准。注意，它是一种标准，而不是某种具体编码，可以看做是编码的一种分类。ANSI的标准就是，ASCII码占用的码位及其所指代的字符不许改变，剩下的自己扩展。</p>
<p>  中国人在这个规定上有自己的扩展（如GBK），英国人也有自己的扩展（如ISO-8859-1,即latin-1）。所以ISO-8859-1和GBK都可以称之为ANSI编码，因为它们符合ANSI规定。以Windows系统为例，中文系统中所指的ANSI编码就是GBK，英文系统中的ANSI编码就是ISO-8859-1。</p>
<h3 id="MBCS">MBCS</h3><p>  多字节字符集(Multi-Byte Character Set)，采用不定长度可以是一个字节，也可以是两个字节，也可以是三个字节来进行编码。大多数情况下2个字节就够用了，汉字就分配两个字节，称之为<strong>DBCS</strong>（Double-Byte Chactacter Set）。</p>
<p>  在Linux系统中看得到MBCS说法，在Windows中呢？其实就是ANSI，ANSI只规定了第一个字节的位置是ASCII，超出这个范围的，肯定也是多字节的了。</p>
<h3 id="CodePage">CodePage</h3><p>  代码页，把一种字符编码方式（和字符集有区别，稍后讲解）放在一个CodePage上，编码解码就像翻书查字典似的。很多个代码页，也就容纳了很多种编码方式。<br>  这个概念最早来自IBM，但也被微软等公司采用。同一种编码方式，在不同的公司制定的CodePage里“页码”也不相同。比如UTF-8，在微软的CodePage里是65001，在IBM里是1208。</p>
<p>  <strong>注意</strong>：MBCS、DBCS、CodePage、ANSI，它们各自指代的不是某种具体编码，而是符合某种规则的编码方式的统称。在不同的操作系统或平台下，它们有一个默认值而已。</p>
<p>  PS： 微软的CP936不等于GBK，它们有几十个不太常用的字符不同。所以绝大多数情况下感觉不到差异。</p>
<h3 id="Unicode/UCS">Unicode/UCS</h3><p>  通过以上的介绍知道，各种解决方案都是各自为政，解决不了 <strong>“同一个系统中同时显示全宇宙的所有字符”</strong> 这个问题。</p>
<p>  于是就有两个组织，他们开始着手做这件事情，UCS和Unicode诞生了。</p>
<ul>
<li><strong>通用字符集</strong>（UCS，Universal Character Set）是由国际标准化组织（ISO）制定的 ISO 10646标准所定义的字符集。通常也译为<strong>通用多八位编码字符集</strong>。</li>
<li><strong>统一码</strong>（Unicode）是由统一码联盟指定的。</li>
</ul>
<p>  后来发现，一山不容二虎，世界人民不需要两个目的相同但是具体实现却有差异的编码方案。UCS和Unicode握手言和，从 Unicode 2.0 起，采用了和ISO 10646-1的编码方案，它们在相同的码位上都对应同样的字符。尽管这两个组织目前还在相互独立的在发布字符编码标准。</p>
<p>  可能是Unicode名字好记，所以采用更为广泛。关于UCS-2，UCS-4这些概念不再赘述，自行查阅。</p>
<h4 id="Unicode，UTF-8，UTF-16它们是什么关系">Unicode，UTF-8，UTF-16它们是什么关系</h4><p>  UTF-8（Unicode Transformation Format）即Unicode转换格式，8的意思是使用8比特为单位来进行编码。码位小于128时，就是对应的字节值；大于等于128时，就会转换成2、3、4字节的序列。每个字节的序列值介于128~255。</p>
<p>  GBK，GB2312，Latin-1，Big-5，ASCII等，它们的字符集和具体编码实现方式绑定（如GBK字符集就采用GBK编码方式），即字符和存储在介质上的二进制流一一对应。缺陷很明显，字符集扩展性差。Unicode考虑了这个问题，所以它的编码与编码的实现方式没有绑定。而是有多种实现方式，如UTF-8，UTF-16，UTF-32。</p>
<p>  例如字符‘A’在Unicode中的编码是65，但存储在介质上时，二进制流的十六进制表示采用UTF-8时是0x41，而UTF-16<strong>大端模式</strong>是0x00 0x41。</p>
<p>  至于什么是大端模式、小端模式，UTF-X，GBXXX的具体编码实现方式请自行查阅。</p>
<h3 id="内码与外码">内码与外码</h3><ul>
<li><strong>内码</strong>：存储在介质上时使用的编码形式。例如GBK，GB2312。</li>
<li><strong>外码</strong>：外部输入系统时的编码。例如拼音输入法编码，仓颉输入法编码。</li>
</ul>
<p>  例如：采用仓颉输入法对汉字“驹”的编码是<code>NMPR</code>，输入系统以后得到字符“驹”。使用GBK作为内码进行存储时就是<code>0xBED4</code>。</p>
<h2 id="乱码产生的原因">乱码产生的原因</h2><p>  <strong>编码和解码时用了不同或者不兼容的字符编码方式。</strong>就算同是Unicode，UTF-8和UTF-16也是不同的。</p>
<p>  <strong>解决乱码问题，需要把握的要点</strong>：</p>
<ul>
<li><strong>输入某软件系统时字符所采用的编码是什么？</strong>（从数据库或文件读取时，原来存储时的编码是什么？从网页抓取时，网页的编码是什么？从控制台输入时，控制台的编码方式是什么？）</li>
<li><strong>软件系统中的编码方式是什么？</strong>（原本若是UTF-8存储，GBK编码的软件系统该如何处理？）</li>
<li><strong>输出时的编码方式是什么？</strong>（如Python脚本处理后的字符串是Unicode编码，输出到采用GBK编码的Windows控制台时应该做什么？）</li>
</ul>
<h2 id="Python_2-x字符编码问题">Python 2.x字符编码问题</h2><h3 id="Python_2_字符（串）类型探究">Python 2 字符（串）类型探究</h3><ul>
<li><p><strong><code>basestring</code></strong> ：str 和 unicode 对象的基类，抽象的，不可被调用或实例化，仅可用于类型检查。<code>isinstance(obj, basestring)</code> 等价于 <code>isinstance(obj, (str, unicode))</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>isinstance(<span class="string">'驹'</span>, basestring)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>isinstance(<span class="string">u'驹'</span>, basestring)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>str</code></strong> ：实际是字节串。Python2中也有<code>bytes</code>对象。<code>bytes == str</code> 结果为<code>True</code>。例如：‘驹’，这个字符串长度为1，但<code>len(&#39;驹&#39;)</code>在windows平台下是2（默认GBK），Linux平台下是3（默认UTF-8）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>isinstance(<span class="string">'驹'</span>, str)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>isinstance(<span class="string">u'驹'</span>, str)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>unicode</code></strong> ：<code>unicode(string[, encoding, errors])</code> ,按照encoding参数指定的编码方式把参数string转换成unicode。unicode编码的字符串对象，也可以直接加前缀u表示。<code>len(u&#39;驹&#39;)</code>在Windows和Linux下都是1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>isinstance(<span class="string">'驹'</span>, unicode)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>isinstance(<span class="string">u'驹'</span>, unicode)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>unicode构造器的参数encoding默认是7位ASCII编码，所以默认时传入的字节串或字符串的每一个字节值必须小于128：</p>
<ul>
<li><p>Windows系统下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Win平台默认情况下就是GBK编码，所以以下结果就是GBK编码值</span><br><span class="line">&gt;&gt;&gt; '驹'</span><br><span class="line">'\xbe\xd4'</span><br><span class="line"></span><br><span class="line"># 报错，试图用 unicode 方法默认的 ASCII 编码去解码 GBK 编码的字符</span><br><span class="line">&gt;&gt;&gt; unicode('驹')</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">......</span><br><span class="line">UnicodeDecodeError: 'ascii' codec can't decode byte 0xbe ...</span><br><span class="line"></span><br><span class="line">#正确，录入时以GBK编码，故而以GBK方式去解码，再转换成 Unicode 形式</span><br><span class="line">&gt;&gt;&gt; unicode('驹', 'GBK')   # 等价于 u'驹'</span><br><span class="line">u'\u9a79'</span><br></pre></td></tr></table></figure>
</li>
<li><p>Linux系统下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Linux平台默认情况下就是UTF-8编码，所以以下结果就是UTF-8编码值</span><br><span class="line">&gt;&gt;&gt; '驹'</span><br><span class="line">'\xe9\xa9\xb9'</span><br><span class="line"></span><br><span class="line"># 报错，试图用 unicode 方法默认的 ASCII 编码去解码 UTF-8 编码的字符</span><br><span class="line">&gt;&gt;&gt; unicode('驹')</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">......</span><br><span class="line">UnicodeDecodeError: 'ascii' codec can't decode byte 0xbe ...</span><br><span class="line"></span><br><span class="line">#正确，录入时以GBK编码，故而以GBK方式去解码，再转换成 Unicode 形式</span><br><span class="line">&gt;&gt;&gt; unicode('驹', 'UTF-8')   # 等价于 u'驹'</span><br><span class="line">u'\u9a79'</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong>总结1： 通过系统shell录入或直接在程序中定义的字符串，Python 2 中默认就是str对象（字节串），其字节值是由系统默认编码方式编码所得，Windows是GBK编码方式，Linux是UTF-8。</strong></p>
<p>所以我们向某个媒介（文件、网页/浏览器、系统Shell或其他软件呈现文本的区域）输出字符串内容时，要用该媒介接收的编码形式编码字符串后再传递给它。</p>
</blockquote>
<p>例如，要从shell中输出字符串时（新手常用urlopen打开一个网页，然后print网页内容），必须将字符串转换为当前的shell使用的编码形式。如，Windows 的 cmd 是GBK，Linux 的 bash 是UTF-8。PyCharm 自带的shell不管是Windows还是Linux都是UTF-8。</p>
</li>
</ul>
<h3 id="encode_与_decode_方法">encode 与 decode 方法</h3><ul>
<li><p><code>S.encode([encoding[,errors]]) -&gt; object</code></p>
<p>文档解释：用编解码器注册的编码方式来<strong>编码</strong>字符串S。encoding参数的默认值就是Python默认的编码方式。errors默认值是’strict’，严格模式，一旦编码出错就抛出 UnicodeEncodeErrors 异常，还可以是’ignore’（忽略错误）, ‘replace’（将出错的字串替换，一般是替换为问号）。</p>
</li>
<li><p><code>S.decode([encoding[,errors]]) -&gt; object</code></p>
<p>文档解释：用编解码器注册的编码方式来<strong>解码</strong>字符串S。参数与encode的一致。</p>
</li>
<li><p>Linux平台下实验观察（Win平台结果也同样，不过是win默认为GBK编码）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = 'abc驹'        # Python2下默认的是str对象，实际是字节串，utf-8编码的</span><br><span class="line">&gt;&gt;&gt; s2 = u'abc驹'       # unicode字符串</span><br><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">'abc\xe9\xa9\xb9'</span><br><span class="line">&gt;&gt;&gt; s2</span><br><span class="line">u'abc\u9a79'</span><br><span class="line"></span><br><span class="line"># 把 str 对象，已经是utf-8编码形式的字串再来encode</span><br><span class="line">&gt;&gt;&gt; s1.encode('UTF-8')</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"># 奇怪的是此处报 UnicodeDecodeError 注意我们用的是encode方法</span><br><span class="line">UnicodeDecodeError: 'ascii' codec can't decode byte 0xe9 ...</span><br><span class="line"></span><br><span class="line"># 把unicode字串按utf-8形式编码，正确</span><br><span class="line">&gt;&gt;&gt; s2.encode('UTF-8')</span><br><span class="line">'abc\xe9\xa9\xb9'</span><br><span class="line"></span><br><span class="line"># 把unicode字串按gbk形式编码，正确</span><br><span class="line">&gt;&gt;&gt; s2.encode('GBK')</span><br><span class="line">'abc\xbe\xd4'</span><br><span class="line"></span><br><span class="line"># 把unicode字串按ASCII编码，用法正确，但报错，因为ASCII编码不了'驹'这个汉字。</span><br><span class="line">&gt;&gt;&gt; s2.encode('ASCII')</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: 'ascii' codec can't encode character u'\u9a79' ...</span><br><span class="line"></span><br><span class="line"># 把unicode字串按ASCII编码，忽略编码不了的错误，不会报错，只剩下能被ASCII编码的字符</span><br><span class="line">&gt;&gt;&gt; s2.encode('ASCII', 'ignore')</span><br><span class="line">'abc'</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结2： encode的作用是将unicode对象（没有某种具体编码）字串按encoding参数给定的编码方式转换为str对象（具有某种具体编码）字串。故而用str对象调用encode方法是错误的。</strong></p>
<p><strong>总结3： decode的作用是将str对象字串（某种具体编码的）按照encoding参数给定的编码方式解码成unicode对象。故而用unicode对象调用decode方法是错误的。</strong></p>
</blockquote>
<p>所以，在使用encode方法时，首先确认是unicode对象在调用它，这个方法会将unicode形式转换成某种具体编码形式的字符串。decode方法是将某种具体的编码的字串解码还原成unicode统一码，必须确认是str对象在调用它，而且encoding参数必须是调用它的字符串的具体编码形式，否则可能出错。</p>
<p>上面三段话多读几遍，被我洗一下脑，然后就明白什么时候该encode, 什么时候该decode，什么时候该传gbk，什么时候该传utf-8，而不是乱猜的。</p>
</li>
</ul>
<h2 id="Python_3-x字符编码问题">Python 3.x字符编码问题</h2><p>  看完了Python2.x中，什么basestring, str, unicode, 一会儿Python默认ascii编码，一会儿系统默认是GBK编码，也是醉了，所以处理多字节编码时一不小心就会出错。</p>
<p>  Python3.x 字符串编码问题轻松了许多，不存在unicode对象了。不论是 <code>&#39;驹&#39;</code> 还是 <code>u&#39;驹&#39;</code> 这两种形式，得到的对象都是<code>str</code> 对象，但内部是unicode方式编码，所以Python3的<code>str</code>对象等价于Python2的<code>unicode</code>对象。</p>
<p>  那么Python2中的<code>str</code>（字节串）对象在Python3中跑到哪儿去了？ 就是<code>bytes</code>对象，就是个字节序列。</p>
<p>  而且Python3中更严格。我们知道Python2中不论是str还是unicode对象，都可以调用decode或encode方法，太混乱。</p>
<p>  在Python3中的<code>str</code>（Python2中的<code>unicode</code>），它是统一码，没有某种具体形式，所以只能被某种具体形式编码，只能调用encode，而不能调用decode。同样，Python3中的<code>bytes</code>对象,如b’\xe9\xa9\xb9’(UTF-8编码形式的’驹’字)，已经具备某种具体编码，只能被解码还原成unicode统一码，所以它之只能调用decode方法，调用encode会报错。</p>
<blockquote>
<p>总结4：<br>Python2 ： <code>str</code>–(decode)–&gt; <code>unicode</code> –(encode)–&gt; <code>str</code><br>Python3 ： <code>bytes</code> –(decode)–&gt; <code>str</code> –(encode)–&gt; <code>bytes</code></p>
</blockquote>
<p>  Python2中的 str 实际是字节串 bytes , Python3中的 str 实际是unicode编码。不论是Python2或Python3，编码转换都须以unicode作为桥梁。那么decode，encode连用的形式就是用于编码转换。</p>
<p>  <strong>对于新手来说重要的例子</strong>，在Windows的cmd中写了几句脚本，抓取了一个UTF-8编码的网页，要在cmd里正确打印，就需要<code>page_content.decode(&#39;UTF-8&#39;).encode(&#39;GBK&#39;)</code>，这样打印就不会出乱码。而在linux平台下，因为bash默认是UTF-8方式编码，所以直接<code>print page_content</code>就可正确显示中文字符。</p>
<h2 id="终极案例">终极案例</h2><p>  写了一个爬虫，抓取的是BIG5编码的繁体中文页面，每抓取一条记录需要从windows控制台打印出来供开发人员查看，而且开发人员还要手动输入一个人工检测编号。然后将检测编号与抓取内容存入以UTF-8方式存储数据的MySQL。虽然是windows平台，但要求以UTF-8的编码保存日志文件。另外其中某段内容你要引用下来放在自己GB2312编码的网页上。</p>
<ol>
<li>如果涉及的编码方式较多，管它三七二十一，先将具体编码的转换成unicode的<br><code>uni_content = page_content.decode(&#39;big5&#39;)</code></li>
<li>打印至windows控制台<br><code>print uni_content.encdoe(&#39;gbk&#39;)</code></li>
<li>开发人员从cmd输入编号<br><code>no = input(&#39;请输入编号&#39;)   # python2用 raw_input() ,得到的是gbk编码形式的字串</code></li>
<li>将编号与原内容组合，存入MySQL，日志也是UTF-8，类似的<br><code>new_content</code> = (no.decode(‘gbk’)+uni_content).encode(‘utf-8’)</li>
<li>将以是UTF-8编码的内容从数据库里拿出来，放入GB2312网页上<br><code>new_page = sql_content.decode(&#39;UTF-8&#39;).encdoe(&#39;GB2312&#39;)</code></li>
</ol>
<h2 id="再次提示">再次提示</h2><p>要解决乱码，明白因为编码解码的方式不一致导致的本质，知道每一次操作中输入是什么编码形式，输出需要什么编码形式，通过unicode为桥梁，去解决问题就好了。</p>
<p>要注意的是，编码间转换数据丢失的问题。例如<code>&#39;abc驹&#39;</code> 能够转换为unicode编码, 通过unicode转为ascii也是可以的，但ascii无法编码汉字，erros参数设为’ignore’时不报错，但只保留下了<code>&#39;abc&#39;</code>。</p>
<h2 id="更多参考">更多参考</h2><ul>
<li><a href="https://docs.python.org/3.5/howto/unicode.html" target="_blank" rel="external">Python3 如何使用 unicode</a></li>
<li><a href="https://docs.python.org/2/howto/unicode.html" target="_blank" rel="external">Python2 如何使用 unicode</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="本文目的">本文目的</h2><p>为 Python 程序员简练地介绍字符编码相关支持，彻底解疑“ Python 中文乱码”，“ Python 2与 Python 3 字符编码差异”等相关问题。使用其他语言的程序员可作参考，道理都是相通的，不过具体处理方式不同罢了。</p>
<h2 id="痛苦的根源">痛苦的根源</h2><ul>
<li><p><strong>起因</strong><br>计算机不能直接识别<strong>字符</strong>（文本的最小组成单位）。</p>
<ul>
<li>字形：<br>字的形状，又叫字图。文字的抽象形状，“小短横线”就是汉字“一”的字形。</li>
<li>字符：<br>抽象符号和数字成对编码用于在计算机系统中表示的信息单位。虽然字符本身是抽象的，但它一旦存在于计算机系统中，它就对应了某种特定字符编码方式。字符“一”在GBK编码中是0xD2BB。</li>
<li>字体：<br>字的形体。草书、行书、楷书，都叫字体。计算机中的字体如：华文行楷，微软雅黑。</li>
</ul>
</li>
<li><p><strong>解决办法</strong><br>但是计算机可以识别二进制数，于是采用一个二进制数来指代一个<strong>字符</strong>。</p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://ajucs.com/tags/Python/"/>
    
      <category term="字符编码" scheme="http://ajucs.com/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python是编译型还是解释型语言？与Java有何不同？]]></title>
    <link href="http://ajucs.com/2015/10/29/python-is-compiler-or-interpreter.html"/>
    <id>http://ajucs.com/2015/10/29/python-is-compiler-or-interpreter.html</id>
    <published>2015-10-29T05:57:40.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<p>前段时间有几个人在群里争论Java和Python是编译型还是解释型语言。阿驹在这里谈谈自己的看法。<br>毕竟作为曾经的Java程序员，猿！</p>
<blockquote>
<p><strong>广而告之:</strong> 学习Python的同学可以加QQ群<code>249708924</code>，或者搜索<code>细学Python</code>即可申请加入。</p>
</blockquote>
<p>以下探讨建立在标准Java、CPython的基础上, 不讨论PyPy等。</p>
<h2 id="先说结论">先说结论</h2><p>Java既是解释型也是编译型，CPython是解释型。<br><a id="more"></a></p>
<h2 id="什么是编译型，什么是解释型">什么是编译型，什么是解释型</h2><p><strong>编译型</strong>：源码——经过编译器编译——机器码——执行。<br><strong>解释型</strong>：源码——经过编译器编译——中间码（字节码）——经过解释器解释——机器码——执行。</p>
<h2 id="Python与Java各自的方式">Python与Java各自的方式</h2><p>Java的执行是 .java 编译成 适配 JVM的 .class字节码，JVM再解释后执行。CPython也几乎一致的过程。<strong>从这点来看，Java和CPython都是解释型</strong>。<br>但是，Java有个JIT机制，即是，经常被调用的代码会直接被编译成机器码，而在此后的执行过程中不再需要解释，这是编译型的特点，所以Java又可以说是编译型的。而CPython没有JIT这一套。<strong>所以CPython就不能说成是编译型</strong>。</p>
<h2 id="本质">本质</h2><p>阿驹说什么东西都喜欢探讨它的本质，那么编译型和解释型，他们实质上有区别吗？<br>没有理解透基础概念的，不必关心下面说的话，免得越学越糊涂。<br>其实，上面对编译型和解释型的理解是比较狭义的。高级语言要拿去执行，中间不都有个编译器去编译一下嘛？从更广义看，所有高级语言都是编译型，也是可解释的，包括C。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前段时间有几个人在群里争论Java和Python是编译型还是解释型语言。阿驹在这里谈谈自己的看法。<br>毕竟作为曾经的Java程序员，猿！</p>
<blockquote>
<p><strong>广而告之:</strong> 学习Python的同学可以加QQ群<code>249708924</code>，或者搜索<code>细学Python</code>即可申请加入。</p>
</blockquote>
<p>以下探讨建立在标准Java、CPython的基础上, 不讨论PyPy等。</p>
<h2 id="先说结论">先说结论</h2><p>Java既是解释型也是编译型，CPython是解释型。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://ajucs.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python编码最佳之最佳实践]]></title>
    <link href="http://ajucs.com/2015/10/09/The-Best-of-the-Best-Practices-Guide-for-Python.html"/>
    <id>http://ajucs.com/2015/10/09/The-Best-of-the-Best-Practices-Guide-for-Python.html</id>
    <published>2015-10-09T03:30:00.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="总体的">总体的</h2><h3 id="价值观">价值观</h3><ul>
<li>把你为自己构建的工具贡献给别人</li>
<li>简单性通常比功能性更好</li>
<li>解决90%的情况，忽略唱反调的</li>
<li>优雅胜于丑陋</li>
<li>构建开源代码（哪怕是为了闭源项目）</li>
</ul>
<h3 id="通用开发准则">通用开发准则</h3><ul>
<li>显式优于隐式</li>
<li>重视可读性</li>
<li>任何人都可以解决任何问题</li>
<li>一旦破窗（糟糕的设计、错误的决定、丑陋的代码）被发现就尽快修复它们  <a id="more"></a>
<blockquote>
<p>注：<a href="https://zh.wikipedia.org/zh-cn/%E7%A0%B4%E7%AA%97%E6%95%88%E5%BA%94" target="_blank" rel="external">破窗效应</a></p>
</blockquote>
</li>
<li>立即做比永不做好</li>
<li>严格测试，为每个新功能/特性写好文档</li>
<li>更重要的是测试驱动开发–人为驱动开发</li>
<li>这些准则很可能会变化</li>
</ul>
<h2 id="特别的">特别的</h2><h3 id="风格">风格</h3><p>遵循<a href="http://www.python.org/dev/peps/pep-0008/" target="_blank" rel="external">PEP8</a>是明智的。</p>
<h4 id="命名">命名</h4><ul>
<li>变量名、函数名、方法名、包名、模块名<ul>
<li><code>lower_case_with_underscores</code> （带下划线小写字母）</li>
</ul>
</li>
<li>类名、异常名<ul>
<li><code>CapWords</code> （单词首字母大写）</li>
</ul>
</li>
<li>保护的方法名和内部函数名<ul>
<li><code>_single_leading_underscore(self, ...)</code> （单下划线开始）</li>
</ul>
</li>
<li>私有方法名<ul>
<li><code>__double_leading_underscore(self, ...)</code> （双下划线开始）</li>
</ul>
</li>
<li>常量名<ul>
<li><code>ALL_CAPS_WITH_UNDERSCORES</code> （全大写带下划线）</li>
</ul>
</li>
</ul>
<h5 id="通用命名准则">通用命名准则</h5><p>尽量避免一个字符的变量名，尤其是l,I,o,O,0等不易区分的。<br>例外：在非常短的代码块中，能从直接的上下文中清晰明了的知道变量含义。</p>
<p><strong>适用情况</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> elements:</span><br><span class="line">    e.mutate()</span><br></pre></td></tr></table></figure></p>
<p>避免多余的标签：<br><strong>可以的</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> audio</span><br><span class="line"></span><br><span class="line">core = audio.Core()</span><br><span class="line">controller = audio.Controller()</span><br></pre></td></tr></table></figure></p>
<p><strong>不可以</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> audio</span><br><span class="line"></span><br><span class="line">core = audio.AudioCore()</span><br><span class="line">controller = audio.AudioController()</span><br></pre></td></tr></table></figure></p>
<p>使用“反向符号”：<br><strong>可以的</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elements = ...</span><br><span class="line">elements_active = ...</span><br><span class="line">elements_defunct = ...</span><br></pre></td></tr></table></figure></p>
<p><strong>不可以</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elements = ...</span><br><span class="line">active_elements = ...</span><br><span class="line">defunct_elements ...</span><br></pre></td></tr></table></figure></p>
<p>避免使用setter和getter方法：<br><strong>可以的</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.age = <span class="number">42</span></span><br></pre></td></tr></table></figure></p>
<p><strong>不可以</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.set_age(<span class="number">42</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="缩进">缩进</h4><p>四个空格，永远不要用制表符tab，说的够多了。</p>
<h4 id="导入">导入</h4><p>导入整个模块而不是单个变量。例如顶级模块<code>canteen</code>中有<code>canteen/sessions.py</code>.</p>
<p><strong>可以的</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> canteen</span><br><span class="line"><span class="keyword">import</span> canteen.sessions</span><br><span class="line"><span class="keyword">from</span> canteen <span class="keyword">import</span> sessions</span><br></pre></td></tr></table></figure></p>
<p><strong>不可以</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> canteen <span class="keyword">import</span> get_user  <span class="comment"># Symbol from canteen/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> canteen.sessions <span class="keyword">import</span> get_session  <span class="comment"># Symbol from canteen/sessions.py</span></span><br></pre></td></tr></table></figure></p>
<p>例外：一些文档中特别注明的应当导入单个变量的第三方代码<br>基本准则：避免循环引用。参考<a href="https://sites.google.com/a/khanacademy.org/forge/for-developers/styleguide/python#TOC-Imports" target="_blank" rel="external">这里</a>。</p>
<p>所有的导入分三个部分放在代码的最上方，每个部分用一个空行分隔，放置顺序：</p>
<ol>
<li>系统/标准库导入（例如 import math）</li>
<li>第三方库/代码导入（例如 import flask）</li>
<li>本地/本项目导入 （例如 import my_module）</li>
</ol>
<p>基本准则：能清楚地知道每个模块来自哪里</p>
<h4 id="文档">文档</h4><p>遵循<a href="http://www.python.org/dev/peps/pep-0257/" target="_blank" rel="external">PEP 257</a>文档字串指南。<a href="http://docutils.sourceforge.net/docs/user/rst/quickref.html" target="_blank" rel="external">reStructured Text</a> 和 <a href="http://sphinx-doc.org/" target="_blank" rel="external">Sphinx</a> 可以帮助强制执行这些标准。</p>
<p>单行文档字符串用于简单的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""返回 ``foo`` 的路径名称。"""</span></span><br></pre></td></tr></table></figure></p>
<p>多行文档字符串应该包括：</p>
<ul>
<li>概括的说明</li>
<li>用例</li>
<li>参数</li>
<li>返回类型和语义</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""Train a model to classify Foos and Bars.</span><br><span class="line"></span><br><span class="line">Usage::</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; import klassify</span><br><span class="line">    &gt;&gt;&gt; data = [("green", "foo"), ("orange", "bar")]</span><br><span class="line">    &gt;&gt;&gt; classifier = klassify.train(data)</span><br><span class="line"></span><br><span class="line">:param train_data: A list of tuples of the form ``(color, label)``.</span><br><span class="line">:rtype: A :class:`Classifier &lt;Classifier&gt;`</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li>使用动词（Return）比名词（Returns）好一些</li>
<li>为类的 <code>__init__</code> 方法添加文档字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""A simple representation of a human being.</span><br><span class="line"></span><br><span class="line">    :param name: A string, the person's name.</span><br><span class="line">    :param age: An int, the person's age.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure>
<h5 id="注释">注释</h5><p>有节制地使用注释。提高代码的可读性比写一大堆注释好。通常情况下，短小的方法比注释有效。<br><strong>不可以</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If the sign is a stop sign</span></span><br><span class="line"><span class="keyword">if</span> sign.color == <span class="string">'red'</span> <span class="keyword">and</span> sign.sides == <span class="number">8</span>:</span><br><span class="line">    stop()</span><br></pre></td></tr></table></figure></p>
<p><strong>可以</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_stop_sign</span><span class="params">(sign)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sign.color == <span class="string">'red'</span> <span class="keyword">and</span> sign.sides == <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_stop_sign(sign):</span><br><span class="line">    stop()</span><br></pre></td></tr></table></figure></p>
<p>当撰写注释时，记得运用“Strunk &amp; White”。</p>
<blockquote>
<p>注：参考《The Elements of Style》，中文译名《文体的要素》。<br>《The Elements of Style》是一本美国英语的写作指南。作者是William Strunk, Jr.和E. B. White。书中包括8个“基本使用规则”，10个“创作的基本原则”，“一些形式的问题”，一个包含49个易误用的单词和表达，57个易拼错的单词的列表。在2011年，时代 (杂志)把The Elements of Style列为从1923年到现在100本最富有影响力的书之一。（摘自维基百科）</p>
</blockquote>
<h4 id="代码行长度">代码行长度</h4><p>无需再强调了。80-100个字符是合适的。使用小括号来延续代码行。</p>
<blockquote>
<p>注：意思是尽量避免使用反斜杠。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wiki = (</span><br><span class="line">    <span class="string">"The Colt Python is a .357 Magnum caliber revolver formerly manufactured "</span></span><br><span class="line">    <span class="string">"by Colt's Manufacturing Company of Hartford, Connecticut. It is sometimes "</span></span><br><span class="line">    <span class="string">'referred to as a "Combat Magnum". It was first introduced in 1955, the '</span></span><br><span class="line">    <span class="string">"same year as Smith &amp; Wesson's M29 .44 Magnum."</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="测试">测试</h3><p>争取100%的测试覆盖率，但不要迷恋覆盖率数字。</p>
<blockquote>
<p>注：不要为了得到一个好看的测试覆盖率而测试，抓住测试的本质——为了保证软件系统按设计正确稳定地运行。覆盖率越高，不一定能保证系统正确性和稳定性越高。</p>
</blockquote>
<h4 id="通用测试准则">通用测试准则</h4><ul>
<li>使用长的描述性的名称。测试方法的名称意义明确就可以避免额外文档字符串或注释。</li>
<li>测试应该是孤立的。避免依赖于真实的数据库和网络。使用单独的测试数据库或使用mock对象。（注：每个测试方法也应当是孤立的，尽量不能相互依赖。）</li>
<li>倾向于使用<a href="https://github.com/rbarrois/factory_boy" target="_blank" rel="external">factories</a>来搭建测试上下文（fixtures）。<blockquote>
<p>注：fixtures是指 <a href="https://en.wikipedia.org/wiki/Test_fixture#Software" target="_blank" rel="external">test fixtures</a>，测试所依赖的数据、条件等一些列特定环境，使得测试结果是可以重复检验的。也被称为测试上下文（test context）。</p>
</blockquote>
</li>
<li>永远不要让未完成的测试通过，否则有遗忘它们的风险。取而代之的是添加一个占位符，例如<code>assert False, &quot;TODO: finish me&quot;</code>。</li>
</ul>
<h4 id="单元测试">单元测试</h4><ul>
<li>专注于每一个小功能。</li>
<li>执行要快，但慢的测试比没有测试好得多。</li>
<li>通常有必要为每个class或model编写对应的测试类。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> factories</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.person = factories.PersonFactory()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_has_age_in_dog_years</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(self.person.dog_years, self.person.age / <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h4 id="功能性测试">功能性测试</h4><p>功能性测试是高层次的测试，接近于终端用户与你系统的交互过程，通常用于Web和GUI程序。</p>
<ul>
<li>为应用场景编写测试，测试用例和测试方法的名称应该和场景描述一致。</li>
<li>在编写测试代码之前，先写明注释。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAUser</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_can_write_a_blog_post</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Goes to the her dashboard</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Clicks "New Post"</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Fills out the post form</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Clicks "Submit"</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Can see the new post</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>注意测试用例和测试方法是如何做到连起来读就像“测试一个用户可以发表一篇博客”的。</p>
<blockquote>
<p>注：正常的功能代码也应该有这样的流畅性。如果代码写得简洁优雅，读起来像读诗一样，就能体会到<strong>Art of</strong> computer programming了。</p>
</blockquote>
<h2 id="灵感来源">灵感来源</h2><ul>
<li><a href="http://www.python.org/dev/peps/pep-0020/" target="_blank" rel="external">PEP 20 (The Zen of Python)</a></li>
<li><a href="http://www.python.org/dev/peps/pep-0008/" target="_blank" rel="external">PEP 8 (Style Guide for Python)</a></li>
<li><a href="http://docs.python-guide.org/en/latest/" target="_blank" rel="external">The Hitchiker’s Guide to Python</a></li>
<li><a href="https://sites.google.com/a/khanacademy.org/forge/for-developers" target="_blank" rel="external">Khan Academy Development Docs</a></li>
<li><a href="http://youtu.be/GZNUfkVIHAY" target="_blank" rel="external">Python Best Practice Patterns</a></li>
<li><a href="http://www.nilunder.com/blog/2013/08/03/pythonic-sensibilities/" target="_blank" rel="external">Pythonic Sensibilities</a></li>
<li><a href="http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X/ref=sr_1_1?ie=UTF8&amp;qid=1381886835&amp;sr=8-1&amp;keywords=pragmatic+programmer" target="_blank" rel="external">The Pragmatic Programmer</a></li>
<li>其他</li>
</ul>
<h2 id="译者注">译者注</h2><ul>
<li><a href="https://osf.io/28rmf/wiki/home/" target="_blank" rel="external">原文链接</a></li>
<li>在翻译的基础上有少许注解</li>
<li>本文是的小、全、精的Python编码指南，但读罢觉得此文还有待改进和补充。感兴趣的同学可以关注本文的后续更新。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="总体的">总体的</h2><h3 id="价值观">价值观</h3><ul>
<li>把你为自己构建的工具贡献给别人</li>
<li>简单性通常比功能性更好</li>
<li>解决90%的情况，忽略唱反调的</li>
<li>优雅胜于丑陋</li>
<li>构建开源代码（哪怕是为了闭源项目）</li>
</ul>
<h3 id="通用开发准则">通用开发准则</h3><ul>
<li>显式优于隐式</li>
<li>重视可读性</li>
<li>任何人都可以解决任何问题</li>
<li>一旦破窗（糟糕的设计、错误的决定、丑陋的代码）被发现就尽快修复它们]]>
    
    </summary>
    
      <category term="Python" scheme="http://ajucs.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[附加应用接入微信第三方平台解决方案]]></title>
    <link href="http://ajucs.com/2015/09/28/addons-in-third-part-wechat-platform.html"/>
    <id>http://ajucs.com/2015/09/28/addons-in-third-part-wechat-platform.html</id>
    <published>2015-09-28T08:01:46.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="附加应用的类型">附加应用的类型</h2><h3 id="1-_插件型">1. 插件型</h3><p>  开发者根据三方平台提供的交互接口/函数/方法，完成一款插件，将代码提交至三方平台审核，审核通过后三方平台将插件代码安装至平台项目中运行，供微信运营者使用。</p>
<ul>
<li><strong>远程接口型</strong><br>插件只需要接收微信粉丝发来的消息，将消息包装为接口要求的格式，向接口发起请求，得到接口返回数据并解析组装为微信要求格式发送给用户。</li>
<li><strong>本地代码型</strong><br>插件自身实现相关功能并返回结果给用户。</li>
</ul>
<h3 id="2-_独立系统型(CRM/ERP等)">2. 独立系统型(CRM/ERP等)</h3><p>根据运维方的不同，分为如下三种形式：<br><a id="more"></a></p>
<ul>
<li><strong>自主运维</strong><br>公众号运营者自己运维的系统，如个人站长的WordPress博客，1号店，京东商城。</li>
<li><strong>第三方平台运维</strong><br>第三方平台运维系统，如有赞商城。</li>
<li><strong>服务商运维</strong><br>由其他服务商依托第三方平台提供的数据或者直接获取微信用户数据进行运维，如有赞平台的ERP进存销系统。</li>
</ul>
<p>根据系统用户信息授权来源不同，可以分为如下几种：</p>
<ul>
<li><strong>无需授权</strong><br>不需要粉丝或者运营者通过微信对该应用进行授权。</li>
<li><strong>代授权</strong><br>公众号运营者先将公众号授权给第三方平台。应用系统使用第三方平台的Appid和Secret，再通过相关接口向粉丝发起授权请求，粉丝信息微信将直接推送至应用系统。</li>
<li><strong>模拟授权</strong><br>通过让粉丝在微信内提交“绑定”信息。</li>
<li><strong>三方平台再授权</strong><br>三方平台再实现OAuth2.0等协议，三方平台的用户（一般是公众号运营者）访问应用系统，应用系统请求授权，应用将得到用户在三方平台上的数据。</li>
</ul>
<hr>
<h2 id="插件型实现方案">插件型实现方案</h2><h3 id="1-_远程接口型">1. 远程接口型</h3><ul>
<li><strong>举例</strong><br>天气/手机号归属/电影票/交通等查询, 在线点歌, 基于小黄鸡等机器人实现的智能问答/聊天机器人等</li>
<li><strong>使用场景</strong><br>用户需要的功能与数据已由其他平台实现与产生，并留有交互接口(没直接接口抓取网页解析也可)。</li>
<li><strong>通信流程</strong><br>查成都天气预报为例<br><img src="http://7xn3rj.com1.z0.glb.clouddn.com/static/images/wechat-addons-01.png" alt="远程接口型通信流程"></li>
</ul>
<h3 id="2-_本地代码型">2. 本地代码型</h3><ul>
<li><strong>举例</strong><br>一战到底，刮刮乐，大转盘，微调研，微官网。微擎的大型附加应用如“人人商城分销版”也是这种形式，有赞商城本质也是这种。</li>
<li><strong>使用场景</strong><br>用户需要与应用互动，互动产生的数据需要存储在本地；或简单的纯信息展示型应用。</li>
<li><strong>通信流程</strong><br>玩大转盘游戏为例<br><img src="http://7xn3rj.com1.z0.glb.clouddn.com/static/images/wechat-addons-02.png" alt="远程接口型通信流程"></li>
</ul>
<h2 id="独立系统型实现方案">独立系统型实现方案</h2><h3 id="1-_无需授权型">1. 无需授权型</h3><ul>
<li><strong>举例</strong><br>侯斯特WordPress伴侣，成都交警，四川汽车票务网</li>
<li><strong>使用场景</strong><ul>
<li>粉丝无需与系统交互，只浏览内容。运营者直接从应用入口管理内容，无需经过第三方平台。微信仅作为一个浏览器，例如成都交警公众号，其交管动态菜单直接指向官方网站。</li>
<li>粉丝与系统交互，但不在系统中产生内容。运营者直接从应用入口管理内容。如侯斯特WordPress伴侣，让粉丝可以通过公众号根据关键字搜索博客内容。</li>
<li>粉丝与系统交互，在系统中产生内容，但应用系统不在乎内容产生着与微信粉丝的身份关系。运营者直接从应用入口管理内容。如四川汽车票务网公众号在线购票。</li>
</ul>
</li>
<li><strong>通信流程</strong><ul>
<li>微信只做浏览器的情况（略）</li>
<li>不在乎粉丝身份的情况（略）</li>
<li>粉丝与系统交互但不产生内容的情况<br>侯斯特WP伴侣为例<br><img src="http://7xn3rj.com1.z0.glb.clouddn.com/static/images/wechat-addons-03.png" alt="无需授权型通信流程"></li>
</ul>
</li>
</ul>
<h3 id="2-_模拟授权型">2. 模拟授权型</h3><ul>
<li><strong>举例</strong><br>招商银行信息查询，工行信息查询</li>
<li><strong>使用场景</strong><br>系统根据微信粉丝身份信息产生结果并返回。例如要通过微信公众号查询“我的余额”，要确定这个微信粉丝的实名信息与欲查询的银行卡信息。在使用功能前，公众号都会要求粉丝提供识别身份的信息，进行绑定。</li>
<li><strong>通信流程</strong><br>查询银行卡余额为例<br><img src="http://7xn3rj.com1.z0.glb.clouddn.com/static/images/wechat-addons-03.png" alt="模拟授权型通信流程"></li>
</ul>
<h3 id="3-_代发起授权型">3. 代发起授权型</h3><ul>
<li><strong>举例</strong><br>京东商城，QQ充值</li>
<li><strong>使用场景</strong><br>针对已成熟在运营的大型、相对独立的应用系统。应用使用公众号appid、平台方的component_appid换取授权令牌，获得微信粉丝基本信息。获得以后，仍需要应用自己处理微信粉丝与系统内会员用户的关联关系。</li>
<li><strong>通信流程</strong><br>略，参考open.weixin.qq.com <a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419318590&amp;token=&amp;lang=zh_CN" target="_blank" rel="external"><strong>代公众号发起网页授权文档</strong></a></li>
</ul>
<h3 id="4-_三方平台再授权型">4. 三方平台再授权型</h3><ul>
<li><strong>举例</strong><br>有赞ERP、进存销等管理系统</li>
<li><strong>使用场景</strong><br>第三方平台运营一个垂直行业，平台本身就是用户针对该行业产生的基础数据，而平台方将针对该行业的增值服务等应用系统，再交由第三方服务商开发运营。平台方通过OAuth2.0等方式，让公众号在服务商处再次授权，允许第三方服务商从平台方获取公众号及公众号粉丝产生的数据，再去服务商处使用服务。<br>这需要服务商有完备的开发、运营、维护能力。不仅是对技术能力的要求。<br>如：公众号托管至有赞，运营微商城，而有赞平台本身不提供完整的ERP/CRM等应用系统，公众号再登录有赞合作服务商应用系统ERP，ERP向公众号运营者发起授权请求，请求公众号允许从有赞获取它的相关数据，公众号运营者允许以后，ERP获得数据，公众号运营者再进入ERP使用相关服务。</li>
<li><strong>通信流程</strong><br>略，参考三方平台从微信获取授权流程。</li>
</ul>
<h2 id="公众号应用安装与卸载">公众号应用安装与卸载</h2><p>  不论是哪种应用形式，第三方平台上要使微信运营者能够进行安装和卸载，都需要在第三方平台上添加一段代码来进行插件的管理。简单的形式只有安装、卸载。较为复杂的大型插件还需要有单独的页面，使运营者能对插件进行各种配置或定制。</p>
<ul>
<li><h4 id="安装">安装</h4><ul>
<li>一个数据集/表存储公众号appid和被安装的模块名称，当点击“安装”以后，在此表中存储已安装插件和相关状态。</li>
<li>除了标记状态之外，还需要公众号内能够进行触发，无需运营者自己再配置。一般以关键词触发，所以需要插件安装的过程就为该公众号增加一条关键词匹配规则。</li>
<li>安装完成以后，公众号粉丝即可通过关键词回复使用插件功能。</li>
</ul>
<p>参考如下的形式记录应用的安装状态和插件相关的设置:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"appid"</span>: <span class="string">"gh_uLVlasdufl"</span>,       <span class="comment">//公众号appid</span></span><br><span class="line">  <span class="string">"installed"</span>: &#123;                  <span class="comment">//已安装的</span></span><br><span class="line">    <span class="string">"guaguale"</span>: &#123;                 <span class="comment">//应用名称</span></span><br><span class="line">      <span class="string">"enable"</span>: <span class="literal">true</span>,             <span class="comment">//是否启用</span></span><br><span class="line">      <span class="string">"other_setting"</span>: <span class="string">"value"</span>    <span class="comment">//插件相关设置</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"dazhuanpan"</span>: &#123;               <span class="comment">//大转盘应用</span></span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="卸载">卸载</h4><p>安装的逆过程。</p>
<ul>
<li>向微信服务器发起请求取消该公众号对应的关键词匹配规则</li>
<li>移除插件安装记录中的相关字段，如上例，卸载”大转盘”应用后，删除对应公众号应用记录中的”dazhuanpan”字段。</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="附加应用的类型">附加应用的类型</h2><h3 id="1-_插件型">1. 插件型</h3><p>  开发者根据三方平台提供的交互接口/函数/方法，完成一款插件，将代码提交至三方平台审核，审核通过后三方平台将插件代码安装至平台项目中运行，供微信运营者使用。</p>
<ul>
<li><strong>远程接口型</strong><br>插件只需要接收微信粉丝发来的消息，将消息包装为接口要求的格式，向接口发起请求，得到接口返回数据并解析组装为微信要求格式发送给用户。</li>
<li><strong>本地代码型</strong><br>插件自身实现相关功能并返回结果给用户。</li>
</ul>
<h3 id="2-_独立系统型(CRM/ERP等)">2. 独立系统型(CRM/ERP等)</h3><p>根据运维方的不同，分为如下三种形式：<br>]]>
    
    </summary>
    
      <category term="wechat" scheme="http://ajucs.com/tags/wechat/"/>
    
      <category term="微信开发" scheme="http://ajucs.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python函数内import和模块顶部import的区别]]></title>
    <link href="http://ajucs.com/2014/11/26/the-difference-between-module-import-and-function-import.html"/>
    <id>http://ajucs.com/2014/11/26/the-difference-between-module-import-and-function-import.html</id>
    <published>2014-11-26T02:20:26.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<h2 id="模块顶部import">模块顶部import</h2><ul>
<li>优点<ul>
<li>可读性好</li>
<li>大多数情况下可以提高加载速度</li>
</ul>
</li>
<li>缺点<ul>
<li>新手容易犯循环依赖导致的ImportError的错误</li>
<li>某些时候会降低加载速度，比如被导入的模块非常大，而本模块的初始化不需要被导入模块</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="函数/方法内部import">函数/方法内部import</h2><ul>
<li>优点<ul>
<li>某些时候能够提高加载速度，因为直到函数被执行时才会去加载</li>
<li>可以避免模块间循环引用产生的ImportError错误</li>
</ul>
</li>
<li>缺点<ul>
<li>可读性较差，难以一目了然地知道当前模块依赖于哪些额外的模块</li>
<li>如果测试不完整，而被导入的模块有错误，则运行过程中会产生不可预估的错误</li>
</ul>
</li>
</ul>
<h2 id="总结">总结</h2><p>应该使用模块顶部导入的方式，除非一定要使用函数内部导入的方式才能完成工作。</p>
<h2 id="import_相关最佳实践">import 相关最佳实践</h2><p>参考<a href="http://ajucs.com/2015/10/09/The-Best-of-the-Best-Practices-Guide-for-Python.html">Python编码最佳之最佳实践</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="模块顶部import">模块顶部import</h2><ul>
<li>优点<ul>
<li>可读性好</li>
<li>大多数情况下可以提高加载速度</li>
</ul>
</li>
<li>缺点<ul>
<li>新手容易犯循环依赖导致的ImportError的错误</li>
<li>某些时候会降低加载速度，比如被导入的模块非常大，而本模块的初始化不需要被导入模块</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
      <category term="Python" scheme="http://ajucs.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MacOSX10.9.4下安装PIL库失败的解决方法]]></title>
    <link href="http://ajucs.com/2014/07/11/OSX-install-PIL-library-failure-solution.html"/>
    <id>http://ajucs.com/2014/07/11/OSX-install-PIL-library-failure-solution.html</id>
    <published>2014-07-11T02:59:59.000Z</published>
    <updated>2016-04-20T06:00:22.894Z</updated>
    <content type="html"><![CDATA[<h2 id="安装PIL库">安装PIL库</h2><p>在Mavericks10.9下安装PIL库失败，这是一个python的图形处理库。错误提示如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jus-iMac:~ ju$ sudo pip <span class="operator"><span class="keyword">install</span> PIL</span><br><span class="line"><span class="keyword">Password</span>:</span><br><span class="line">Downloading/unpacking PIL</span><br><span class="line">  Could <span class="keyword">not</span> find <span class="keyword">any</span> downloads that satisfy the requirement PIL</span><br><span class="line">    <span class="keyword">Some</span> <span class="keyword">externally</span> hosted files were ignored (<span class="keyword">use</span> <span class="comment">--allow-external PIL to allow).</span></span><br><span class="line">Cleaning up...</span><br><span class="line"><span class="keyword">No</span> distributions <span class="keyword">at</span> all <span class="keyword">found</span> <span class="keyword">for</span> PIL</span><br><span class="line">Storing debug <span class="keyword">log</span> <span class="keyword">for</span> <span class="keyword">failure</span> <span class="keyword">in</span> /<span class="keyword">Users</span>/ju/<span class="keyword">Library</span>/<span class="keyword">Logs</span>/pip.<span class="keyword">log</span></span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>再根据错误提示，使用如下命令安装：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">sudo</span> <span class="comment">pip</span> <span class="comment">install</span> <span class="comment">PIL</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">allow</span><span class="literal">-</span><span class="comment">external</span> <span class="comment">PIL</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">allow</span><span class="literal">-</span><span class="comment">unverified</span> <span class="comment">PIL</span></span><br></pre></td></tr></table></figure></p>
<p>仍然出错。但这次错误提示变了：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> <span class="keyword">file</span> included from _imagingtk.c:19:</span><br><span class="line">/Applications/Xcode.<span class="keyword">app</span>/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/<span class="keyword">include</span>/tk.<span class="keyword">h</span>:78:11: fatal <span class="keyword">error</span>: 'X11/Xlib.<span class="keyword">h</span>' <span class="keyword">file</span> not found</span><br><span class="line">#       <span class="keyword">include</span> &lt;X11/Xlib.<span class="keyword">h</span>&gt;</span><br><span class="line">                ^</span><br><span class="line">1 <span class="keyword">error</span> generated.</span><br><span class="line"><span class="keyword">error</span>: command '<span class="keyword">cc</span>' failed with <span class="keyword">exit</span> status 1</span><br></pre></td></tr></table></figure></p>
<p>安装原版PIL解决办法如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/</span>MacOSX.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/MacOSX10.9.sdk/</span>System<span class="regexp">/Library/</span>Frameworks<span class="regexp">/Tk.framework/</span>Versions<span class="regexp">/8.5/</span>Headers<span class="regexp">/X11 /</span>usr<span class="regexp">/local/</span>include/X11</span><br><span class="line">export CFLAGS=-Qunused-arguments</span><br><span class="line">export CPPFLAGS=-Qunused-arguments</span><br><span class="line">sudo pip install PIL --allow-external PIL --allow-unverified PIL</span><br></pre></td></tr></table></figure></p>
<h2 id="使用Pillow代替PIL">使用Pillow代替PIL</h2><p>因为PIL已经很久没更新，而且对Python3不支持。Pillow是从PIL fork的一个分支，更新及时，对Python2/3支持都很友好。完全兼容PIL，可以成为PIL的代替品。<br>安装步骤如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew <span class="operator"><span class="keyword">install</span> libtiff libjpeg webp <span class="keyword">little</span>-cms2</span><br><span class="line">$ pip <span class="keyword">install</span> Pillow</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="安装PIL库">安装PIL库</h2><p>在Mavericks10.9下安装PIL库失败，这是一个python的图形处理库。错误提示如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jus-iMac:~ ju$ sudo pip <span class="operator"><span class="keyword">install</span> PIL</span><br><span class="line"><span class="keyword">Password</span>:</span><br><span class="line">Downloading/unpacking PIL</span><br><span class="line">  Could <span class="keyword">not</span> find <span class="keyword">any</span> downloads that satisfy the requirement PIL</span><br><span class="line">    <span class="keyword">Some</span> <span class="keyword">externally</span> hosted files were ignored (<span class="keyword">use</span> <span class="comment">--allow-external PIL to allow).</span></span><br><span class="line">Cleaning up...</span><br><span class="line"><span class="keyword">No</span> distributions <span class="keyword">at</span> all <span class="keyword">found</span> <span class="keyword">for</span> PIL</span><br><span class="line">Storing debug <span class="keyword">log</span> <span class="keyword">for</span> <span class="keyword">failure</span> <span class="keyword">in</span> /<span class="keyword">Users</span>/ju/<span class="keyword">Library</span>/<span class="keyword">Logs</span>/pip.<span class="keyword">log</span></span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="PIL" scheme="http://ajucs.com/tags/PIL/"/>
    
      <category term="Pillow" scheme="http://ajucs.com/tags/Pillow/"/>
    
      <category term="Python" scheme="http://ajucs.com/tags/Python/"/>
    
  </entry>
  
</feed>
